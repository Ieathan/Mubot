 // Three dependencies.
angular.module('myApp', ['angularMoment', 'monospaced.elastic', 'ngDisableScroll'])
.config(['$locationProvider', '$compileProvider', ($locationProvider, $compileProvider) => {
  // optimizations.
  $compileProvider.commentDirectivesEnabled(false);
  $compileProvider.cssClassDirectivesEnabled(false);
  $compileProvider.debugInfoEnabled(false);
  // ensure html5 is required
  $locationProvider.html5Mode({ enabled: true, requireBase: false })
}])
// Here we explicitly require injections (array format) such that during minitifcation the implicit calls are not needed.
.controller('mainController', ['$scope', '$http', '$location', '$timeout', '$window', 'socket', ($scope, $http, $location, $timeout, $window, socket) => {
  // VARIABLE DECLARATIONS.
  const TYPING_TIMER = {}; // Keep track of whoes typing.
  $scope.state = document.cookie.substr(document.cookie.indexOf("state")+6, document.cookie.indexOf(";")-6);
  $scope.replyto = ""; $scope.loaded = {}; $scope.usersOnline = {};
  // Every time the script is requested load the posts, and user information
  $http.get("/bitmark/api/posts").then((res) => { $scope.posts = res.data });
  $http.get("/bitmark/api/info").then((res) => {
    $scope.pms = res.data.private_messages || [];
    delete res.data.private_messages;
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      // I merge in exists: true here so that the backend knows this window isn't
      // being opened. Its just being loaded, minimized windows are requested too.
      socket.emit("private message open", Object.assign($scope.pms[i], {exists: true}))
    }
    // Dont need do do this, but makes things cleaner.
    delete res.data._id; delete res.data.__v; //delete res.updated_at;
    $scope.data = res.data;
    $scope.data.awaiting_pm = res.data.awaiting_pm || {}
console.log(res.data)
    var amount = 0;
    // Loop through every notification, and add up the amounts per.
    for(i = 0, l = $scope.data.notifications.length; i < l; ++i) {
     amount += $scope.data.notifications[i].amount;
    }
    $scope.notificationAmount = amount;
  });
  // If the script has been disconnected for multiple attempts reload the script. data is recon attempts.
  socket.on('reconnect', attempts => attempts > 1 && (window.location.href = "/bitmark"))
  // Request the users online.
  socket.emit("users online", {});
  socket.on("new post", post => {
    $scope.posts.push(post)
    if(post.ismarking) {
      $scope.usersOnline[post.replyto_user] && $scope.usersOnline[post.replyto_user].balance++
      $scope.usersOnline[post.username] && $scope.usersOnline[post.username].balance--
      for(let i = 0, l = $scope.posts.length; i < l; ++i) post.replyto === $scope.posts[i]._id && $scope.posts[i].marks++
    }
    // Post is replying to user.
    if(post.replyto_user === $scope.data.username) {
      // Post is also marking user
      if(post.ismarking) $scope.data.balance++
      if(!post.message) {
        for(let i = 0, l = $scope.pms.length; i < l; ++i) {
          // Post is marking user and user has pm window open with
          // the user creating the marking.
          if($scope.pms[i].username === post.username) {
            let ref = $scope.pms[i].history;
            for(let j = 0, l2 = ref.length; j < l2; j++) {
              // Post is marking users pm.
              if(post.replyto === ref[j]._id) {
                 ref[j].ismarked = true;
                 return;
              }
            }
          }
        }
      }
      let found = false;
      // Loop through user's notifications to check if post already has notifications.
      for(let i = 0, l = $scope.data.notifications.length; i < l; ++i) {
        // User already has notifications about this post, increment amount.
        if(post.replyto === $scope.data.notifications[i].id) {
          $scope.data.notifications[i].amount++;
          found = true
        }
      }
      // User doesnt have notifications about this post, add it.
      if(!found) $scope.data.notifications.push({id: post.replyto, amount: 1, message: post.message})
      // increment total notification counter.
      $scope.notificationAmount++
      // Post is marking user's pm.
    }
  });
  socket.on("private message data", updatePms)
  socket.on("user logged in", user => $scope.usersOnline[user.username] = user);
  socket.on("user logged out", user => delete $scope.usersOnline[user.username]);
  socket.on("users online", usersOnline => $scope.usersOnline = usersOnline);
  // New user notification.
  socket.on("new notification", notification => {
  });

  $scope.$watch(scope => Object.keys(scope.usersOnline).length, (newVal, oldVal, scope) => scope.amountOnline = newVal)

  $scope.notificationClicked = notification => {
    $scope.notificationAmount -= notification.amount;
    $scope.select({'_id' : notification.id });
    for(i = 0, l = $scope.data.notifications.length; i < l; ++i) {
     if(notification.id === $scope.data.notifications[i].id) { $scope.data.notifications.splice(i, 1); break }
    }
    $http.get("/bitmark/api/delete_notification/" + notification.id).then(()=>{})
  };
  $scope.reasonBlur = post => {
    $scope.cancel = false;
    $scope.isDisabled = true;
    $timeout(() => {
      $scope.isDisabled = false;
      if (!$scope.cancel) {
        $scope.data.message_needed[post._id] = false;
        $scope.mark(post)
      }
    }, 200)
  };
  const PM_WIDTH = 300;
  $scope.closePmWindow = pm => {
    var found;
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      if(pm === $scope.pms[i]) {
        $scope.pms.splice(i, 1);
        found = i;
      }
    }
    for(let i = found-1; i >= 0; i--) {
      rightOffset = parseInt($scope.pms[i].style.right.slice(0, -2));
      rightOffset -= PM_WIDTH + 10;
      $scope.pms[i].style.right = rightOffset + 'px';
    }
    socket.emit("private message close", pm)
  };
  // Checks if the pms fit on the screen.
  $(window).on("resize", _.throttle(function () {
      $scope.$apply(function(){
        var len = $scope.pms.length;
        if((len) * PM_WIDTH + (len * 10) + 150 > $window.innerWidth) {
          // pms dont fit, remove one.
          $scope.pms.shift()
        }
      });
  }, 200));
  // return true if we need to sip msg.
  $scope.skipSameMin = () => $scope.data.skipSameMins && $scope.data.skipSameMins--;
  // The getSameMin function groups all the msgs with the same min into 1 block then
  // it sets skipSameMins to the amount of msgs it grouped, so we can skip displaying them.
  $scope.getSameMin = (history, index) => {
    var results = [];
    var i = index;
    // While the next history element has the same minnute. So i represents, relative to index, the amount found.
    while(history[i+1] && $scope.sameMin(history[i].date, history[i+1].date) && history[i].sender === history[i+1].sender) {
      results.push(history[i].message + "\n");
      ++i;
    }
    if(i > index) {
      // The above while loop doesnt add the last i.
      results.push(history[i].message);
      // Make sure to skip over all the entries with same min
      // Since we are grouping them up into one next command.
      $scope.data.skipSameMins = results.length - 1;
      return results.join('');
   } else {
      // The next message is a diff min. so return msg alone.
      return history[index].message;
    }
  };
  // Returns true if prev and cur message have same day/min respectivly.
  $scope.sameDay = (prev, cur) => new Date(prev).getDay() === new Date(cur).getDay();
  $scope.sameMin = (prev, cur) => new Date(prev).getMinutes() === new Date(cur).getMinutes();

  $scope.togglePmWindow = pm => {
    pm.maximized = !pm.maximized;
    // If pm is maxmized increase height and make sure they dont have awaiting pm notifications. Otherwise reduce height.
    pm.maximized ? (pm.style.height = '348px') && delete $scope.data.awaiting_pm[pm.username] : pm.style.height = "34px";
    // Persist changes.
    socket.emit("private message toggle", pm)
  };
  function updatePms(pms) {
   if(!pms[0]) return;
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      // Loop through current pms and update only the right pm window.
      if(pms[0].receiver === $scope.pms[i].username || pms[0].sender === $scope.pms[i].username) {
        $scope.pms[i].history = $scope.pms[i].history.concat(pms)
      }
    }
  }
  // Throttle here to improve performance if typing is nonstop.
  $scope.startedTyping = _.throttle(function(pm) {
    // pm.username is the person receiving the pm.
    const data = {user: pm.username, started: true}
    socket.emit("private_messages typing", data)
  }, 500);
  socket.on("private_messages typing", data => {
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      if(data.user === $scope.pms[i].username) {
        if(data.finished) {
           $scope.pms[i].istyping = false;
           if(TYPING_TIMER[data.user]) return $timeout.cancel(TYPING_TIMER[data.user])
        } else {
          return startTypingTimer(i);
        }
      }
    }
  })
  function startTypingTimer(index) {
      var ref = $scope.pms[index];
      ref.istyping = true;
      if(TYPING_TIMER[ref.username]) {
        $timeout.cancel(TYPING_TIMER[ref.username])
      }
      TYPING_TIMER[ref.username] = $timeout(() => ref.istyping = false, 3750)
  };
  //openPmWindow
  $scope.privateMessage = user => {
    var rightOffset, len, pm;
    if(len = $scope.pms.length) {
      for(let i = 0; i < len; ++i) {
        if(user.username === $scope.pms[i].username) {
          // The window exists, so mazimize/minimize it.
         if($scope.pms[i].minimized) delete $scope.data.awaiting_pm[$scope.pms[i].username]
          $scope.togglePmWindow($scope.pms[i]);
          return
        }
      }
    }
    // 150 is the user-list width. len * 10 is spacing.
    if((len+1) * PM_WIDTH + (len * 10) + 150 > $window.innerWidth) {
      $scope.pms.shift()
      //return alert("To many windows!")
    }
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      rightOffset = parseInt($scope.pms[i].style.right.slice(0, -2));
      rightOffset += PM_WIDTH + 10;
      $scope.pms[i].style.right = rightOffset + 'px';
    }
    // 150 is the user-list width. len * 10 is spacing.
    rightOffset = 150 + 10;
    pm = { text: "", history: [], maximized: true, istyping: false, username: user.username, style: { right: rightOffset } };
    pm.style = { 'background-color': '#ffffff',  'border': '1px solid #b0b0b0', 'bottom': '0', 'display': 'none',
      'height': '348px', 'position': 'fixed', 'right': rightOffset + 'px', 'width': '300px', 'font-family': "'Open Sans', sans-serif"
    }
    $scope.pms.push(pm)
    socket.emit("private message open", pm)
  };
  $scope.markPm = pm => {
    socket.emit("mark private message", pm, marked => marked && (pm.ismarked = 1) && $scope.data.balance--)
  }
  $scope.mark = post => {
    $scope.data.message_needed[post._id] = false;
    post.marking_msg = $scope.data.marking_msg; $scope.data.marking_msg = "";
    $scope.data.username === post.username || $http.post("/bitmark/api/mark/", post).then(()=>{ $scope.data.balance-- }); //post.marks++ });
  };
  $scope.updateState = (path, state, scroll) => {
    scroll = scroll || 0;
    var cookie_state = state;
    if (state == 'home') {
      if ($scope.replyto.length === 24) cookie_state = $scope.replyto
    }
    $location.old = $location.state({scrollto: scroll});
    $location.new = {
      //selected_post: (function(){
      //  if($scope.replyto.length !== 24) return '';
      //  else if($window.innerWidth < 951) return { 'width': '65vw' };
      //  else if($window.innerWidth < 751) return { 'width': '90vw' };
      //  else return { 'width': '45vw' };
      //})(),
      replyto: $scope.replyto,
      state: cookie_state,
      scrollto: scroll
    };
    try { if ($location.new.state === $location.old.state) return; } catch(e) {} //Error is thrown first time page is loaded since $location.old is undefined.
    state === 'home' && (state = '');
    $location.state($location.new).path(path + state);
  };
  $scope.updateState("/bitmark/", "home");
  $scope.select = post => {
    if($scope.replyto === post._id) return;
    //$scope.selected_post = {"width": "45vw"};
    //if($window.innerWidth < 951) $scope.selected_post = { 'width': '65vw' }
    //if($window.innerWidth < 751) $scope.selected_post = { 'width': '90vw' }
    $scope.replyto = post._id;
    document.cookie = 'state=' + post._id + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    $scope.state = post._id;
    post.scrollto = document.documentElement.scrollTop || document.body.scrollTop
    $scope.updateState('/bitmark/post/', post._id, post.scrollto);
  };
  if ($scope.state.length === 24) $scope.select({'_id': $scope.state});
  // Watch for location changes so we can apply state accordingly
  $scope.$on('$locationChangeSuccess', (_, __, ___, ____, oldstate) => {
    var state_data = $location.state()
    if (!state_data) return
    $scope.selected_post = state_data.selected_post;
    $scope.replyto = state_data.replyto;
    $scope.state = state_data.state;
    document.cookie = 'state=' + state_data.state + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
    if(!oldstate) oldstate = {}
    setTimeout(() => {
      window.scrollTo(0, (oldstate.scrollto || 0));
    }, 0)
  });
  $scope.postGlow = post => {
    return {  "box-shadow" : "0 0 " + post.marks / 2 + "px purple" };
  };
  $scope.mergeStyles = styles => {
    var obj = {};
    for(let i = 0, l = styles.length; i < l; ++i) {
      //let keys = Object.keys(styles[i])
      //let j = -1, len = keys.length;
      //while(++j < len) { key = keys[j]; obj[key] = styles[i][key] }
      for(let key in styles[i]) obj[key] = styles[i][key];
    }
    return obj;
  };
  $scope.back = post => {
    document.cookie = 'state=' + post.replyto + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    if (post.replyto) {
      $scope.state = post.replyto;
      $scope.replyto = post.replyto;
      $scope.updateState('/bitmark/post/', post.replyto)
    } else {
      //$scope.selected_post = "";
      $scope.replyto = "";
      $scope.updateState('/bitmark/', 'home');
    }
  };
  socket.on("new private message", pm => {
    var found = false;
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      if(pm.sender === $scope.pms[i].username || pm.receiver === $scope.pms[i].username) {
        $scope.pms[i].history.push(pm);
        found = true;
      }
    }
    if(!found) {
      let cancel = false;
      for(pm of $scope.pms) if(pm.username === pm.sender) cancel = true;
      if(cancel) return;
      let ref = $scope.data.awaiting_pm;
      ref[pm.sender] = ref[pm.sender] ? ref[pm.sender]++ : 1;
    }
  })
  $scope.createPm = ($event, message, username) => {
    $event.preventDefault();
    socket.emit("new private message", {message: message, username: username})
    $event.target.value = "";
  };
  $scope.create = $event => {
    $http.post("/bitmark/api/create", { 'message': $scope.data.message, 'replyto': $scope.replyto }).then(res => {
      $event.preventDefault();
      $scope.data.message = "";
      $event.target.blur();
      $event.target.rows = 1;
    }).catch(err => {$scope.create($event); console.log("ERROR CREATING, TRYING AGAIN!")})
  };
  $scope.cancelMarking = post => {
    $scope.data.message_needed[post._id] = false;
    data.marking_msg = '';
    $scope.cancel = true;
  };
  $scope.logout = () => {
    socket.emit("log out", {});
    document.cookie = 'login-cookie' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    document.cookie = 'state' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    window.location.href = "/bitmark";
  };
}])
.filter('reverse', () => {
  return items => {
    if (items) return items.slice().reverse();
  }
})
.directive('autoFocus', () => {
  return {
    link: {
      post: (scope, element) => { element[0].focus() }
    }
  }
})
.directive('autoscroll', () => {
   return {
     restrict: 'A',
     link: (scope, elem, attr) => {
       scope.$watch(() => {
         return elem[0].scrollHeight;
       }, (newVal, oldVal) => {
         // This directive is just for pms and
         // 275px is our pm initial size, so skip it.
         if (!newVal || newVal === '275px') return;
         elem[0].scrollTop = elem[0].scrollHeight;
       });
     }
   }
})
.directive('loaded', () => {
   var navBarLoaded = false;
   return {
     restrict: 'A',
     link: (scope, elem, attr) => {
       scope.$watch(() => {
         try { return document.getElementById(attr.loaded).scrollHeight } catch(e) { return }
       }, (newVal, oldVal) => {
         if (!newVal) return;
         if(newVal - oldVal == 42) return; // Hack to fix bug: (textarea is sending 2 scrollheight updates when its drawn)
         if (attr.loaded == "navbar" && navBarLoaded) return;
         if (!navBarLoaded) navBarLoaded = true;
         elem[0].style.paddingTop = newVal + 10 + 'px';
       });
     }
   }
})
.factory('socket', ['$rootScope', function ($rootScope) {
  const socket = io('/bitmark');
  return {
    on: function (eventName, callback) {
      socket.on(eventName, function () {
        const args = arguments;
        $rootScope.$apply(function () {
          callback.apply(socket, args);
        });
      });
    },
    emit: function (eventName, data, callback) {
      socket.emit(eventName, data, function () {
        const args = arguments;
        $rootScope.$apply(function () {
          if (callback) {
            callback.apply(socket, args);
          }
        });
      })
    }
  };
}])

