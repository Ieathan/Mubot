secp256k1 = require('secp256k1');
{ createHash, randomBytes } = require('crypto');
eccrypto = require('eccrypto');


function Encryption(privateKey) {
  this.privateKey = privateKey || this.newKey(randomBytes(32));
  this.publicKey = elliptic.createPublicKey(privateKey);
  this.signatures = [];
  this.publicEncryptionKeys = [];
}
Encryption.prototype.newKey =
     _ => !(_.compare((new Buffer('0000000000000000000000000000000000000000000000000000000000000001', 'hex'))) < 0)
       && !(_.compare((new Buffer('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140', 'hex'))) > 0)
          ? _
     : genKey(randomBytes(32)) ;

Encryption.prototype.sign = function(message) {
  var hash = createHash(sha256).update(message).digest());
  var signature = secp256k1.sign(hash, this.privateKey);
  this.signatures.push(signature)
  return signature;
}

Encryption.prototype.encrypt = function(publicKey, message) {
  return eccrypto.encrypt(publicKey, buffer(message)
    .then(function(encrypted) {
      _this.
    })
}


if (typeof window !== 'undefined') {
 document.getElementById('crypto').innerHTML = privateKey.toString('hex');
} else {
  console.log(privateKey.toString('hex'))
  console.log(publicKey.toString('hex'))
}
