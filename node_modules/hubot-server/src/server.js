// Description:
//   An https server for hubot
//
// Requirements:
//   You must install express 4 and update bot.coffee accordingly (this is done automatically with mubot)
//
// INIT
const path         = require('path');                              // Used for cross platform file system support.
const querystring  = require('querystring');                       // Handy for parsing urls.
const favicon      = require('serve-favicon') ;                    // Favicon middlerware for express.
// BITMARK SPECIFIC INIT
const express      = require('express');                           // Used for setting up static directories.
const randomstring = require("randomstring");                      // Used for cookie generation.
const exec         = require('child_process').exec;                // Used to access bitmark-cli.
const fs           = require('fs');                                // Used to copy over the users default img.
const ROOT         = path.join(__dirname, '/../');                 // Server root path.
const LOGS_ROOT    = ROOT + 'logs/';                               // Bitmark root path.
const BITMARK_ROOT = ROOT + 'bitmark/';                            // Bitmark root path.
const API_ROOT     = ROOT + 'api/';                                // API root path.
const mongoose     = require('mongoose');                          // Our database.
const multer       = require('multer');                            // Express file upload middleware.
const request      = require('request')
//const TransactionsSchema = new mongoose.Schema({
//  "date": { type: Date, default: Date.now },
//  "txid": String,
//  "amount": Number,
//  "address": String,
//  "confirms": Number,
//}, { id: false });
// Beautiful hack to allow hotreloading when models already exists.
//const Transactions = mongoose.models.Transactions || mongoose.model('Transactions', TransactionsSchema)
//
// Will simplify later, sets up the uploaded files name and path multer middleware.
const storage      = multer.diskStorage({
  destination: (req, file, cb) => { cb(null, BITMARK_ROOT + 'uploads/') },
  filename: (req, file, cb) => {
    Users.findOne({"login-cookie": req.headers.cookie.split("login-cookie=")[1].split(';')[0] }, (err, user) => {
      if(err) return next(err);
      cb(null, user.username);
    })
  }
})
//
// BITMARK DATABASE CONNECT (MIGRATE TO bot.BRAIN's REDDIS SERVER IN FUTURE!!!)
mongoose.Promise = global.Promise;
mongoose.connect('mongodb://localhost/bitmark-api', { useMongoClient: true })
  .then(() => console.log('[MONGOOSE] Connection succesful.'))
  .catch((err) => console.error("[MONGOOSE ERROR] " + err));
// Set up database.
const PmsSchema = new mongoose.Schema({
  "sender": String,
  "receiver": String,
  "ismarking": String,
  "message": String,
  "date": { type: Date, default: Date.now },
});
const PostsSchema = new mongoose.Schema({
  "username": String,
  "marks": Number,
  "replyto": String,
  "ismarking": String,
  "message": String,
  "date": { type: Date, default: Date.now },
}, { id: false });
const UsersSchema = new mongoose.Schema({
  "username": String,
  "login-cookie": String,
  "password": String,
  "wallet": String,
  "balance": Number,
  "reputation": Number,
  "notifications": Array,
  "private_messages": Array,
  updated_at: { type: Date, default: Date.now },
});
// Beautiful hack to allow hotreloading when models already exists.
const Users = mongoose.models.Users || mongoose.model('Users', UsersSchema);
const Posts = mongoose.models.Posts || mongoose.model('Posts', PostsSchema);
const Pms   = mongoose.models.Pms   || mongoose.model('Pms',   PmsSchema);
//
// MAIN
module.exports = bot => {
  const io = bot.io.bitmark = bot.io.of('/bitmark');
  // Server wide FavIcon
  bot.router.use(favicon(ROOT + 'public/favicon.ico'))
  bot.router.use("/", express.static(ROOT + 'public'))
  bot.router.use("/profile", express.static(ROOT + 'profile'))
  bot.router.get("/chat", (req, res) => res.sendFile(ROOT + 'public/io.html'));
  bot.router.use("/logs", express.static(LOGS_ROOT + 'public'))
  bot.router.get("/logs", (req, res) => res.sendFile(LOGS_ROOT + 'logs.html'));
  bot.router.get("/logs/:server", (req, res) => res.sendFile(LOGS_ROOT + 'logs.html'));
  bot.router.get("/walletnotify/:coin/:txid", function(req, res) {
    exec(`bitmarkd getrawtransaction ${req.params.txid} 1`, (err, trans) => {
      try {
        trans = JSON.parse(trans.trim().replace(/(\n|\\)/g,''))
        for(var i=0; i<trans.vout.length; i++) {
          if ((index = bot.brain.data.keys['_'+req.params.coin].indexOf(trans.vout[i].scriptPubKey.addresses[0])) > -1) {
            user = bot.brain.data.keys[bot.brain.data.keys['_'+req.params.coin][index+1]]
            if(!trans.confirmations) break
            else if(user[req.params.coin].txids.indexOf(req.params.txid) > -1) break
            else {
              user[req.params.coin].txids.push(req.params.txid);
              user[req.params.coin].balance += parseFloat(trans.vout[i].value * 1000).toFixed(8);
              //console.log("Wallet notify script has just updated a users balance.");
            }
          }
        }
      } catch(e) { res.end(0); console.log("Error after wallet notify: " + e) }
    })
    res.end("Ok.")
  })
  // Post to discord.

  bot.router.get('/discord', (req, res) => {
    res.sendFile(ROOT + 'public/discord.html')
  });
  bot.router.post("/discord", (req, res) => {
    bot.messageRoom(req.body.channel, req.body.comment)
    //res.writeHead(200, {'Content-Type': 'text/plain'})
    res.end("Your message has been sent.")
  })
  // Crypto API -> ATM Redirect main page here.
  bot.router.use("/api", express.static(API_ROOT + 'public'))
  bot.router.get(["/", "/api/gambling", "/api/crypto"], (req, res) => {
    res.sendFile(API_ROOT + 'api.html')
  })
  bot.router.get("/api", (req, res) => {
    var query = querystring.parse(req._parsedUrl.query)
    if (query) {
      bot.emit("CryptoRequest", query, res)
    } else {
      res.sendFile(API_ROOT + 'api.html')
    }
  })
  bot.router.get("/ip", (req, res) => {
    res.writeHead(200, {'Content-Type': 'text/plain'})
    var ip;
    if (req.headers['x-forwarded-for']) {
      ip = req.headers['x-forwarded-for'].split(",")[0];
    } else if (req.connection && req.connection.remoteAddress) {
      ip = req.connection.remoteAddress;
    } else {
      ip = req.ip;
    }
    if(ip.toString().indexOf('127.0.0.1') > -1) res.end("Hi leathan")
    else res.end(ip)
  })
  // BITMARK
  bot.router.use("/bitmark", express.static(BITMARK_ROOT + 'public'))
  bot.router.use("/uploads", express.static(BITMARK_ROOT + 'uploads'))

  bot.router.post('/bitmark/uploads', multer({ storage: storage }).single('upl'), (req,res) => {
    res.sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  bot.router.get('/bitmark', (req, res, next) => {
     res.sendFile(BITMARK_ROOT + 'bitmark.html')
  });
  /* GET /wallet */
  bot.router.get('/bitmark/wallet', (req, res, next) => {
    res.cookie("state", 'wallet').sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  /* GET /profile */
  bot.router.get('/bitmark/profile', (req, res, next) => {
    res.cookie("state", 'profile').sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  /* GET /users/:username */
  bot.router.get('/bitmark/users/:username', (req, res, next) => {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") }, (err, user) => {
      if (err) return next(err);
      if (user) { res.send("This is " + user.username + "'s profile. <br> They have " + user.balance + " marks.") }
      else { res.send("That user does not exist.") }
    });
  });
  /* POST /users/login */
  bot.router.post('/bitmark/users/login', (req, res, next) => {
    var login_cookie = randomstring.generate();
    Users.findOneAndUpdate({'username': new RegExp("^" + req.body.username + "$", "i"), 'password': req.body.password },  {"login-cookie": login_cookie },  (err, post) => {
      if (err) return next(err)
      if (post) res.cookie("login-cookie",login_cookie).end("") // Set their login cookie.
      else res.end("ERROR")
    });
  });
  /* POST /users/createAccount */
  bot.router.post('/bitmark/users/createAccount', (req, res, next) => {
    Users.findOne({username: req.body.username }, (err, user) => {
      if (err) return next(err);
      if (user) { res.json({error: 'Username already exists.'}) }
      else {
        exec('bitmarkd getnewaddress', (error, stdout) => {
          req.body.wallet = stdout.trim();
          req.body.balance = 10;   // This is a temporary balance that im funding.
          req.body.reputation = 0; // For future use.
          Users.create(req.body, (err, post) => {
            fs.createReadStream(BITMARK_ROOT + 'public/images/default-user-image.png').pipe(fs.createWriteStream(BITMARK_ROOT + 'uploads/' + req.body.username));
            if (err) return next(err);
            res.json(post);
          });
        });
      }
    });
  });
  bot.router.get('/bitmark/post/:id', (req, res, next) => {
    res.cookie("state", req.params.id).sendFile(BITMARK_ROOT + '/bitmark.html');
    //res.cookie("state", req.params.id, { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + '/bitmark.html');
  });
  // API
  //bot.router.get('/bitmark/reset', (req, res, next) => { // lets just hope no one reads this untill i remove it.
  //  Posts.deleteMany({},()=>{});
  //  Users.deleteMany({},()=>{});
  //  res.json({});
  //});
  bot.router.get('/bitmark/api/posts', (req, res, next) => {
    Posts.find((err, posts) => {
      if (err) return next(err);
      res.json(posts);
    });
  });
  bot.router.get('/bitmark/api/replies', (req, res, next) => {
    Posts.find({ "replyto": { $exists: true } }, (err, replies) => res.json(replies || err))
  });
  bot.router.get('/bitmark/api/marks', (req, res, next) => {
    Posts.find({ "ismarking": { $exists: true } }, (err, markings) => res.json(markings || err))
  });
  bot.router.get('/bitmark/api/post/:id', (req, res, next) => {
    Posts.findById(req.params.id, (err, post) => { res.json(post) })
  });
  bot.router.get('/bitmark/api/marks_received/:username', (req, res, next) => {
    Post.find({ "ismarking": req.params.username }, (err, markings) => res.json(markings || err))
  });
  bot.router.get('/bitmark/api/marks_given/:username', (req, res, next) => {
    Post.find({ "username": req.params.username, "ismarking": { $exists: true } }, (err, markings) => res.json(markings || err))
  });
  bot.router.get('/bitmark/api/info/:username', (req, res, next) => {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") }, (err, user) => {
      if (user) {
        user.password = ""; user['login-cookie'] = ""; // Don't return the sensitive information via ajax response
        res.json(user);
      } else {
        res.json({error: "User doesn't exist"})
      }
    });
  });
  // API - Cookie needed
  bot.router.get('/bitmark/api/info', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, function (err, user) {
      if (user) {
        user.password = ""; user['login-cookie'] = ""; // Don't return the sensitive information via ajax response
        res.json(user)
      } else {
        // They are not logged in so send a stub.
        res.json({"_id":"Guest","username":"Guest","password":"","wallet":"","balance":0,"reputation":0,"__v":0,"login-cookie":"","updated_at":"","notifications":[]})
      }
    });
  });
  bot.router.post('/bitmark/api/mark', (req, res, next) => {
    Posts.findOne({"_id": req.body._id}, function (err, marked_post) {
      if (err) res.end(err)
      Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, marking_user) => {
        if (!marking_user || marking_user.balance < 1) return;                                                          // NOT LOGGED IN / NOT ENOUGH FUNDS
        createNotification({"_id": marked_post._id, "username": marked_post.username, "message": marked_post.message}); // CREATE NOTIFICATION
        Users.findByIdAndUpdate( marking_user._id,                   { $inc: { "balance": -1 } }, ()=>{});              // SUBTRACT BALANCE FROM SENDER
        Users.findOneAndUpdate({ "username": marked_post.username }, { $inc: { "balance":  1 } }, ()=>{});              // MARK POST
        Posts.findOneAndUpdate({ "_id": req.body._id },              { $inc: { "marks"  :  1 } }, ()=>{});              // ADD BALANCE TO RECEIVER
        Posts.create({"replyto": marked_post._id, "username": marking_user.username, "ismarking": marked_post.username, "message": req.body.marking_msg, "marks": 0 },
          (err, marking) => {
            if(err) return res.end(err);
            io.emit("new post", marking)
            res.json(marking)
          }
        )
      })
    })
  });
  bot.router.get('/bitmark/api/delete_notification/:id', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, user) => {
      if (err) return next(err);
      Users.findOneAndUpdate({'username': user.username }, { $pull: { 'notifications': {'id': req.params.id.toString() } } }, { multi: true }, (e, user) => {
        res.json(user)
      })
    })
  });
  bot.router.post('/bitmark/api/create', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, creating_user) => {
      if (!creating_user) { res.json({error: "Not logged in."}); return; } // NOT LOGGED IN
      req.body.marks = 0;
      req.body.username = creating_user.username;
      Posts.create(req.body, (err, created_post) => {
        if(err) return res.end(err)
        io.emit("new post", created_post)
        res.json(created_post);
        if (req.body.replyto) {
          Posts.findById(req.body.replyto, (err, post) => {
            if (post.username != creating_user.username) { createNotification(post) } // Dont create notification is user is replying to themselves
          })
        }
      })
    })
  });
  // Save every users socket, by user.
  io.sockets.users = {};
  var usersOnline = {};
  function updateLoggedIn(socket, loggedIn, cb) {
    try {
      const cookie = socket.handshake.headers.cookie.split('login-cookie')[1].split(';')[0].slice(1)
      Users.findOne({ "login-cookie": cookie }, (err, user) => {
        if(user) {
          var cleanedUser = {}
           cleanedUser.username = user.username;
           cleanedUser.reputation = user.reputation;
           cleanedUser.balance = user.balance;
           cleanedUser.updated_at = user.updated_at;
          if(loggedIn) {
            if(!io.sockets.users[user.username]) {
              io.emit("user logged in", cleanedUser)
              usersOnline[user.username] = cleanedUser;
            }
            io.sockets.users[user.username] = socket;
            if(cb) cb(user.username)
          } else {
            if(io.sockets.users[user.username]) {
              delete io.sockets.users[user.username];
              socket.broadcast.emit("user logged out", user)
              delete usersOnline[user.username];
            }
          }
        } else {
          if(cb) cb(false)
        }
      })
    } catch(e) {
      // Guest logged in / out.
    }
  }
  io.on("disconnect", socket => {
    updateLoggedIn(socket, false);
  })
  io.on("connection", socket => {
    updateLoggedIn(socket, true, username => {
      if(!username) return;
      socket.on("need pm data", withUser => {
        console.log("request from " + username + " for " + withUser)
        getPms(username, withUser, pms => {
          console.log("Found " + pms.length)
          socket.emit("needed pm data", pms)
          console.log('socket.emit("needed pm data", pms) - DONE')
        });
      })
      socket.on("new private message", pm => {
console.log("Emitting typing finished to " + pm.user.username)
        io.sockets.users[pm.user.username].emit("private_messages typing", {user: username, finished: true})
        createPm(username, pm, processedPm => {
          socket.emit("new private message", processedPm);
          io.sockets.users[processedPm.receiver].emit("new private message", processedPm);
          console.log("Emmited to " + processedPm.receiver)
         console.log(processedPm)
        });
      })
      socket.on("private_messages change", private_messages => {
        console.log("private_messages change")
        Users.findOneAndUpdate({ "username": username }, { private_messages: private_messages }, ()=>{});

      })
      socket.on("private_messages typing", data => {
        console.log(username + " is typing")
        io.sockets.users[data.user].emit("private_messages typing", {user: username})
      })
    });
    socket.emit("users online", usersOnline)
  })
  // catch 404 not found
  bot.router.use((req, res, next) => {
    res.end('<h1>Not Found Dawg</h1>');
  });
  // error handler
  bot.router.use((err, req, res, next) => {
    //res.locals.message = err.message;
    //res.locals.error = req.app.get('env') === 'development' ? err : {};
    res.status(err.status || 500);
    res.end('<h1>Weird Error Yo</h1>');
  });

  function getPms(user, withUser, cb, amount) {
    amount = amount || 100;
    var query = Pms.find({ $or:[ {sender: user, receiver: withUser}, {sender: withUser, receiver: user} ]}).sort({'date': -1}).limit(amount);
//    var query = Pms.find({sender: user, receiver: withUser}).sort({'date': -1}).limit(amount);
    query.exec((err, pms) => {
      cb(pms)
    });
  }

  function createPm(sender, pmData, cb) {
    var pm = {}
    pm.sender = sender;
    pm.receiver = pmData.user.username;
    pm.message = pmData.text;
    pm.ismarking = pmData.ismarking || '0';
    Pms.create(pm, (err, pm) => cb(pm))
  }

  function createNotification(post) {
    var amount = 1; var index = -1; var found;
    Users.findOne({'username': post.username}, (err, user) => {
      user.notifications.forEach((n, i) => {
        if (n.id.toString() == post._id.toString()) { amount = n.amount + 1; found = i }
      });
      // A post has receiced anther notification.
      if (amount > 1) {
        var obj = {};
        obj["notifications."+found] = { 'id': post._id.toString(), 'message': post.message, 'amount': amount };
        Users.findOneAndUpdate({'username': post.username}, { $set: obj }, (err, user) => {
          try {
            io.sockets.users[post.username].emit("new data", user)
          }
          catch(e) {} // They arn't logged on do nothing
        });
       }
      // New post notification
      else {
        Users.findOneAndUpdate({'username': post.username},
          { $push: { 'notifications': { 'id': post._id.toString(),  'message': post.message,  'amount': amount } } }, ()=>{})
      }
    })
  }
}
