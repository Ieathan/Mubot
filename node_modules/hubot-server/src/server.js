// Description:
//   An https server for hubot
//
// Requirements:
//   You must install express 4 and update bot.coffee accordingly (this is done automatically with mubot)
//
// INIT
const log          = process.env.SERVER_LOG_LEVEL;  // Wether or not to display debugging info
const path         = require('path');               // Used for cross platform file system support.
const querystring  = require('querystring');        // Handy for parsing urls.
const favicon      = require('serve-favicon') ;     // Favicon middlerware for express.
// BITMARK SPECIFIC INIT
const express      = require('express');            // Used for setting up static directories.
const randomstring = require("randomstring");       // Used for cookie generation.
const exec         = require('child_process').exec; // Used to access bitmark-cli.
const fs           = require('fs');                 // Used to copy over the users default img.
const ROOT         = path.join(__dirname, '/../');  // Server root path.
const LOGS_ROOT    = ROOT + 'logs/';                // Bitmark root path.
const BITMARK_ROOT = ROOT + 'bitmark/';             // Bitmark root path.
const API_ROOT     = ROOT + 'api/';                 // API root path.
const mongoose     = require('mongoose');           // Our database.
const multer       = require('multer');             // Express file upload middleware.
const request      = require('request')
//const TransactionsSchema = new mongoose.Schema({
//  "date": { type: Date, default: Date.now },
//  "txid": String,
//  "amount": Number,
//  "address": String,
//  "confirms": Number,
//}, { id: false });
// Beautiful hack to allow hotreloading when models already exists.
//const Transactions = mongoose.models.Transactions || mongoose.model('Transactions', TransactionsSchema)
//
// Will simplify later, sets up the uploaded files name and path multer middleware.
const storage      = multer.diskStorage({
  destination: (req, file, cb) => { cb(null, BITMARK_ROOT + 'uploads/') },
  filename: (req, file, cb) => {
    Users.findOne({"login-cookie": req.headers.cookie.split("login-cookie=")[1].split(';')[0] }, (err, user) => {
      if(err) return next(err);
      cb(null, user.username);
    })
  }
})
//
// BITMARK DATABASE CONNECT (MIGRATE TO bot.BRAIN's REDDIS SERVER IN FUTURE!!!)
mongoose.Promise = global.Promise;
mongoose.connect('mongodb://localhost/bitmark-api', { useMongoClient: true })
  .then(() => log && console.log('[MONGOOSE] Connection succesful.'))
  .catch((err) => console.error("[MONGOOSE ERROR] " + err));
// Set up database.
const PmsSchema = new mongoose.Schema({
  "sender": String,
  "receiver": String,
  "ismarked": Number,
  "message": String,
  "date": { type: Date, default: Date.now },
});
const PostsSchema = new mongoose.Schema({
  "username": String,
  "marks": Number,
  "replyto": String,
  "replyto_user": String,
  "ismarking": Number,
  "message": String,
  "date": { type: Date, default: Date.now },
}, { id: false });
const UsersSchema = new mongoose.Schema({
  "username": String,
  "login-cookie": String,
  "password": String,
  "wallet": String,
  "balance": Number,
  "reputation": Number,
  "notifications": Array,
  "pms": Array,
  "awaiting_pm": Object,
  updated_at: { type: Date, default: Date.now },
});
// Beautiful hack to allow hotreloading when models already exists.
const Users = mongoose.models.Users || mongoose.model('Users', UsersSchema);
const Posts = mongoose.models.Posts || mongoose.model('Posts', PostsSchema);
const Pms   = mongoose.models.Pms   || mongoose.model('Pms',   PmsSchema);
//
// MAIN
module.exports = bot => {
  const io = bot.io.bitmark = bot.io.of('/bitmark');
  // Server wide FavIcon
  bot.router.use(favicon(ROOT + 'public/favicon.ico'))
  bot.router.use("/", express.static(ROOT + 'public'))
  bot.router.use("/profile", express.static(ROOT + 'profile'))
  bot.router.get("/chat", (req, res) => res.sendFile(ROOT + 'public/io.html'));
  bot.router.use("/logs", express.static(LOGS_ROOT + 'public'))
  bot.router.get("/logs", (req, res) => res.sendFile(LOGS_ROOT + 'logs.html'));
  bot.router.get("/logs/:server", (req, res) => res.sendFile(LOGS_ROOT + 'logs.html'));
  bot.router.get("/walletnotify/:coin/:txid", function(req, res) {
    exec(`bitmarkd getrawtransaction ${req.params.txid} 1`, (err, trans) => {
      try {
        trans = JSON.parse(trans.trim().replace(/(\n|\\)/g,''))
        for(var i=0; i<trans.vout.length; i++) {
          if ((index = bot.brain.data.keys['_'+req.params.coin].indexOf(trans.vout[i].scriptPubKey.addresses[0])) > -1) {
            user = bot.brain.data.keys[bot.brain.data.keys['_'+req.params.coin][index+1]]
            if(!trans.confirmations) break
            else if(user[req.params.coin].txids.indexOf(req.params.txid) > -1) break
            else {
              user[req.params.coin].txids.push(req.params.txid);
              user[req.params.coin].balance += parseFloat(trans.vout[i].value * 1000).toFixed(8);
              //log && console.log("Wallet notify script has just updated a users balance.");
            }
          }
        }
      } catch(e) { res.end(0); console.log("Error after wallet notify: " + e) }
    })
    res.end("Ok.")
  })
  // Post to discord.
  bot.router.get('/discord', (req, res) => {
    res.sendFile(ROOT + 'public/discord.html')
  });
  bot.router.post("/discord", (req, res) => {
    bot.messageRoom(req.body.channel, req.body.comment)
    //res.writeHead(200, {'Content-Type': 'text/plain'})
    res.end("Your message has been sent.")
  })
  // Crypto API -> ATM Redirect main page here.
  bot.router.use("/api", express.static(API_ROOT + 'public'))
  bot.router.get(["/", "/api/gambling", "/api/crypto"], (req, res) => {
    res.sendFile(API_ROOT + 'api.html')
  })
  bot.router.get("/api", (req, res) => {
    var query = querystring.parse(req._parsedUrl.query)
    if (query) {
      bot.emit("CryptoRequest", query, res)
    } else {
      res.sendFile(API_ROOT + 'api.html')
    }
  })
  bot.router.get("/ip", (req, res) => {
    res.writeHead(200, {'Content-Type': 'text/plain'})
    var ip;
    if (req.headers['x-forwarded-for']) {
      ip = req.headers['x-forwarded-for'].split(",")[0];
    } else if (req.connection && req.connection.remoteAddress) {
      ip = req.connection.remoteAddress;
    } else {
      ip = req.ip;
    }
    if(ip.toString().includes('127.0.0.1')) res.end("Hi leathan")
    else res.end(/(\d{1,3}\..*)/.exec(ip)[1] || "Idk")
  })
  // BITMARK
  bot.router.use("/bitmark", express.static(BITMARK_ROOT + 'public'))
  bot.router.use("/uploads", express.static(BITMARK_ROOT + 'uploads'))

  bot.router.post('/bitmark/uploads', multer({ storage: storage }).single('upl'), (req,res) => {
    res.sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  bot.router.get('/bitmark', (req, res, next) => {
     res.sendFile(BITMARK_ROOT + 'bitmark.html')
  });
  /* GET /wallet */
  bot.router.get('/bitmark/wallet', (req, res, next) => {
    res.cookie("state", 'wallet').sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  /* GET /profile */
  bot.router.get('/bitmark/profile', (req, res, next) => {
    res.cookie("state", 'profile').sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  /* GET /users/:username */
  bot.router.get('/bitmark/users/:username', (req, res, next) => {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") }, (err, user) => {
      if (err) return next(err);
      if (user) { res.send("This is " + user.username + "'s profile. <br> They have " + user.balance + " marks.") }
      else { res.send("That user does not exist.") }
    });
  });
  /* POST /users/login */
  bot.router.post('/bitmark/users/login', (req, res, next) => {
    var login_cookie = randomstring.generate();
    Users.findOneAndUpdate({'username': new RegExp("^" + req.body.username + "$", "i"), 'password': req.body.password },  {"login-cookie": login_cookie },  (err, post) => {
      if (err) return next(err)
      if (post) res.cookie("login-cookie",login_cookie).end("") // Set their login cookie.
      else res.end("ERROR")
    });
  });
  /* POST /users/createAccount */
  bot.router.post('/bitmark/users/createAccount', (req, res, next) => {
    if(/(^_|[^a-zA-Z0-9_])/.test(req.body.username)) return res.end({error: 'Illegally formatted name'});
    Users.findOne({username: req.body.username }, (err, user) => {
      if (err) return next(err);
      if (user) { res.json({error: 'Username already exists.'}) }
      else {
        exec('bitmarkd getnewaddress', (error, stdout) => {
          req.body.wallet = stdout.trim();
          req.body.balance = 10;   // This is a temporary balance that im funding.
          req.body.reputation = 0; // For future use.
          req.body.pms = [];
          req.body.awaiting_pms = [];
          Users.create(req.body, (err, post) => {
            fs.createReadStream(BITMARK_ROOT + 'public/images/default-user-image.png').pipe(fs.createWriteStream(BITMARK_ROOT + 'uploads/' + req.body.username));
            if (err) return next(err);
            res.json(post);
          });
        });
      }
    });
  });
  bot.router.get('/bitmark/post/:id', (req, res, next) => {
    res.cookie("state", req.params.id).sendFile(BITMARK_ROOT + '/bitmark.html');
    //res.cookie("state", req.params.id, { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + '/bitmark.html');
  });
  // API
  //bot.router.get('/bitmark/reset', (req, res, next) => { // lets just hope no one reads this untill i remove it.
  //  Posts.deleteMany({},()=>{});
  //  Users.deleteMany({},()=>{});
  //  res.json({});
  //});
  bot.router.get('/bitmark/reset', (req, res, next) => { // lets just hope no one reads this untill i remove it.
    Users.findOneAndUpdate({ username: 'leathan' }, { $set: { notifications: [] } }, function(err, user){
      res.json({});
    });
  });
  bot.router.get('/bitmark/api/posts', (req, res, next) => {
     Posts.find({message: {$ne: ""}}).sort({date: -1}).exec((err, posts) => res.json(posts || {}));
  });
  bot.router.get('/bitmark/api/replies', (req, res, next) => {
    Posts.find({ "replyto": { $exists: true } }, (err, replies) => res.json(replies || {}))
  });
  bot.router.get('/bitmark/api/marks', (req, res, next) => {
    Posts.find({ "ismarking": { $exists: true } }, (err, markings) => res.json(markings || {}))
  });
  bot.router.get('/bitmark/api/post/:id', (req, res, next) => {
    Posts.findById(req.params.id, (err, post) => { res.json(post || {}) })
  });
  bot.router.get('/bitmark/api/marks_received/:username', (req, res, next) => {
    Post.find({ "ismarking": { $exists: true },  "replyto_user": req.params.username }, (err, markings) => res.json(markings || {}))
  });
  bot.router.get('/bitmark/api/marks_given/:username', (req, res, next) => {
    Post.find({ "username": req.params.username, "ismarking": { $exists: true } }, (err, markings) => res.json(markings || {}))
  });
  bot.router.get('/bitmark/api/info/:username', (req, res, next) => {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") },
    // Don't return the sensitive information via ajax response
    {'awaiting_pm': false, 'password': false, 'login-cookie': false, 'notifications': false},
    (err, user) => {
      res.json(user || {error: "User doesn't exist"})
    });
  });
  // API - Cookie needed
  bot.router.get('/bitmark/api/info', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, {'password': false, 'login-cookie':false}, function (err, user) {
      if (user) {
        res.json(user)
      } else {
        // They are not logged in so send a stub.
        res.json({"username":"Guest","wallet":"","balance":0,"reputation":0,"updated_at":"","notifications":[],"pms":[]})
     }
    });
  });
  bot.router.post('/bitmark/api/mark', (req, res, next) => {
    Posts.findById(req.body._id, function (err, marked_post) {
      if (err) return res.end(err)
      // Find user if balance > 0 and subtract marking amount (1 always for now)
      Users.findOneAndUpdate({"login-cookie": req.cookies["login-cookie"], "balance": {$gt: 0} }, { $inc: { 'balance': -1 } }, (err, marking_user) => {
        if(!marking_user) return res.json({error: 'finding marking user or decrementing their balance'})
        createNotification(marked_post.toJSON());
        // Increment the in memory value as well.
        usersOnline[marked_post.username] && ++usersOnline[marked_post.username].balance;
        usersOnline[marking_user.username] && --usersOnline[marking_user.username].balance;
        // Add balance to receiver
        Users.findOneAndUpdate({ "username": marked_post.username }, { $inc: { "balance": 1 } }, ()=>{
          // Increment the in memory value as well.
          usersOnline[marked_post.username] && ++usersOnline[marked_post.username].balance;
        });
        // MARK POST
        Posts.findByIdAndUpdate( marked_post._id , { $inc: { "marks" : 1 } }, ()=>{});
        Posts.create({"replyto_user": marked_post.username, "replyto": marked_post._id, "username": marking_user.username, "ismarking": 1, "message": req.body.marking_msg, "marks": 0 },
        (err, marking) => {
          if(err) return res.end(err);
          io.emit("new post", marking)
          res.json(marking || {})
        })
      })
    })
  });
  bot.router.get('/bitmark/api/delete_notification/:id', (req, res, next) => {
    Users.findOneAndUpdate({"login-cookie": req.cookies["login-cookie"]}, { $pull: { 'notifications': {'id': req.params.id } } }, (err, user) => {
      if (err) return res.end(err);
      res.json(user || {})
    })
  });
  bot.router.post('/bitmark/api/create', (req, res, next) => {
    // Post text has nothing or just whitespace, dont continue.
    if(!req.body.message.trim()) return;
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, creating_user) => {
      if (!creating_user) { return res.json({error: "Not logged in."}); return; } // NOT LOGGED IN
      req.body.marks = 0;
      req.body.username = creating_user.username;
      if (req.body.replyto) {
        Posts.findById(req.body.replyto, (err, post) => {
          req.body.replyto_user = post.username;
          createPost(req.body);
          if (post.username !== creating_user.username) { createNotification(post.toJSON()) } // Dont create notification is user is replying to themselves
        })
      } else createPost(req.body);
      function createPost(post) {
        Posts.create(post, (err, created_post) => {
          if(!created_post) { console.log("Critical error creating post"); return res.end({}) }
          io.emit("new post", created_post)
          res.json(created_post);
        })
      }
    })
  });
  function logOut(user) {
    Users.findOneAndUpdate({'username': user }, { 'login-cookie': 'logged-out' }, (err, user) => {
      delete logged[user['login-cookie']]
    })
    io.sockets.users[user].broadcast.emit("user logged out", user);
    delete usersOnline[user]
    delete io.sockets.users[user]
  }
  // Save every users socket, by user.
  io.sockets.users = {};
  const usersOnline = {}, logged = {};
  function isLoggedIn(socket, cb) {
    if(socket.handshake.headers.cookie) {
      let cookie;
      if(cookie = /login-cookie=(\w{32})/.exec(socket.handshake.headers.cookie)) cookie = cookie[1];
      else return cb(false)
      if(logged[cookie]) {
        io.sockets.users[logged[cookie]] = socket;
        return cb(logged[cookie]);
      }
      // If this is our first time seeing the user, query database and build shortcut hashes.
      Users.findOne({ "login-cookie": cookie }, (err, user) => {
        if(err) throw new Error('Error @ Users.findOne({ "login-cookie": cookie }, (err, user) => {');
        if(!user) return cb(false); // Bad cookie.
        let cleanedUser = {
          balance:    user.balance,
          username:   user.username,  // make sure sensitive info isn't sent.
          reputation: user.reputation,
          status:     'online',
          updated_at: user.updated_at
        }
        io.emit("user logged in", cleanedUser)
        logged[cookie] = user.username;
        usersOnline[user.username] = cleanedUser; // shortcut hashes
        io.sockets.users[user.username] = socket;
        cb(user.username);
      })
    } else {
      cb(false);
      // Guest logged in - out.
    }
  }
  io.on("connection", socket => {
    //socket.on("disconnect", socket => updateLoggedIn(socket, false)); This event is fired on refresh...
    isLoggedIn(socket, username => {
      if(!username) return; // Its a guest.
      socket.on("status update", status => {
        if(!usersOnline[username]) usersOnline[username] = {};
console.log(usersOnline[username].status)
        if(status === usersOnline[username].status) return;
        if(status === 'recently-away' && usersOnline[username].status === 'away') return;
        status === 'offline' ? delete usersOnline[usrname] : usersOnline[username].status = status;
        socket.broadcast.emit("status update", {username: username, status: status})
      });
      socket.on("window focus", isFocused => usersOnline[username].windowblured = isFocused);
      socket.on("log out", () => logOut(username) && socket.broadcast.emit("user logged out", username));
      socket.on("private message open", pm => {
        if(pm.maximized) pmRead(username, pm)
        // dont log history for now..
        delete pm.history; delete pm.text;
        if(pm.exists) delete pm.exists
        else Users.findOneAndUpdate({ "username": username }, { $push: { "pms": pm } }, (err, user) => {
          log && console.log(pm.username + "'s private message opened or loaded by " + username + ".")
        });
        getPms(username, pm.username, pms => socket.emit("private message data", pms))
      })
      socket.on("mark private message", (pm, cb) => markPm(username, pm, cb));
      socket.on("new private message", pm => {
        if(io.sockets.users[pm.username]) io.sockets.users[pm.username].emit("private_messages typing", { user: username, finished: true })
        createPm(username, pm, processedPm => {
          socket.emit("new private message", processedPm);
          if(io.sockets.users[processedPm.receiver]) io.sockets.users[processedPm.receiver].emit("new private message", processedPm);
        });
      })
      socket.on("private message toggle", pm => {
        if(pm.maximized) pmRead(username, pm)
        delete pm.history; delete pm.text;
        var data = "pms.username" + pm.username;
        Users.findOneAndUpdate({ "username": username, "pms.username": pm.username  }, { $set: { "pms.$": pm } }, {new: true}, (err, user) => {
         log && console.log(pm.username + "'s private message toggled by " + username + ". PM.MAXIMIZED: " + pm.maximized)
        });
      })
      socket.on("private message close", pm => {
        Users.findOneAndUpdate({ "username": username }, { $pull: { pms: { "username": pm.username } } }, (err, user) => {
          log && console.log(pm.username + "'s private message closed by " + username + ".")
        });
      })
      socket.on("private_messages typing", data => {
        if(io.sockets.users[data.user]) io.sockets.users[data.user].emit("private_messages typing", {user: username})
      })
    });
    socket.on("users online", () => socket.emit("users online", usersOnline))
  })
  function pmRead(username, pm) {
    Users.findOneAndUpdate({ "username": username }, { $unset: {['awaiting_pm.' + pm.username]: 1} }, {new: true}, (err, user) => {
     log && console.log(pm.username + "'s private message read by " + username + ".")
    })
  }
  function getPms(user, withUser, cb, amount) {
    amount = amount || 100;
    Pms.find({ $or:[ {sender: user, receiver: withUser}, {sender: withUser, receiver: user} ]}).sort({'date': -1}).limit(amount).exec((err, pms) => {
      log && console.log(withUser + "'s private messages loaded by " + user + ".")
      cb(pms.reverse() || {})
    });
  }
  function markPm(user, pm, cb) {
  if(pm.ismarked || user === pm.sender || usersOnline[user].balance < 1) return cb(false);
    Pms.findOneAndUpdate(pm, {ismarked: 1}, (err, pm) => {
      if(err || !pm) return cb(false);
      // Here we increment/decrement the database balances, plus the in memory values.
      Users.findOneAndUpdate({ "username": user }, { $inc: { "balance": -1 } }, ()=> usersOnline[user] && --usersOnline[user].balance);
      Users.findOneAndUpdate({ "username": pm.sender }, { $inc: { "balance": 1 } }, ()=> usersOnline[pm.sender] && ++usersOnline[pm.sender].balance);
      Posts.create({"replyto": pm._id.toString(), "replyto_user": pm.sender, "username": user, "ismarking": 1, "marks": 0 }, (err, marking) => io.emit("new post", marking || {}));
      cb(!!pm)
    })
  }
  function createPm(sender, pmData, cb) {
    var pm = {sender: sender, receiver: pmData.username, message: pmData.message}
    Pms.create(pm, (err, pm) => {
      // Only add another notification if this pm isnt posted the same
      // minute as the pm before (thats what .sameMin indicates)
      if(!pmData.sameMin) {
        Users.findOneAndUpdate({ username: pmData.username,
        $or: [
          { "pms.username": { $not: new RegExp('^'+sender+'$') } },
          { $and: [
            {"pms.maximized": false},
            {"pms.username": sender }
          ] }
        ] }, { "$inc": {['awaiting_pm.' + sender]: 1} }, (e, u) => {
          if(!u) log && console.log(pmData.username + " is not awaiting " + sender + "'s pm because he has that window open.")
          else log && console.log(sender + "'s pm is awaited by " + pmData.username + ".")
        })
      }
      cb(pm || {})
    })
  }
  function createNotification(post) {
    notification = {
      id: post._id.toString(),
      amount: 1, // Amount of notifications per post, defaults to 1.
      message: post.message
    }
    Users.findOne({'username': post.username}, (err, user) => {
      // Iterator for notifications.
      var i = 0;
      for(let l = user.notifications.length; i < l; i++) {
        let n = user.notifications[i];
        // This user already has notification for this post so increment the amount.
        if (n.id === notification.id) { notification.amount += n.amount; break }
      };
      // A post has receiced anther notification.
      if (notification.amount > 1) {
        // The dot notation here is mongoose specific meaning notifications[found]. Its NOT a hash obj.
        Users.findOneAndUpdate({'username': post.username}, {$set: {['notifications.' + i]: notification} })
      }
      // New post notification
      else {
        Users.findOneAndUpdate({'username': post.username}, { $push: { 'notifications': notification } })
      }
    })
  }
  // catch 404 not found
  bot.router.use((req, res, next) => {
    res.end('<h1>Not Found Dawg</h1>');
  });
  // error handler
  bot.router.use((err, req, res, next) => {
    res.status(err.status || 500);
    res.end('<h1>Weird Error Yo</h1>')
  });
}

