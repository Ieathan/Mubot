// Description:
//   An https server for hubot
//
// Requirements:
//   You must install express 4 and update robot.coffee accordingly (this is done automatically with mubot)
//
// INIT
const path         = require('path');                              // Used for cross platform file system support.
const querystring  = require('querystring');                       // Handy for parsing urls.
const favicon      = require('serve-favicon') ;                    // Favicon middlerware for express.
// BITMARK SPECIFIC INIT
const express      = require('express');                           // Used for setting up static directories.
const randomstring = require("randomstring");                      // Used for cookie generation.
const exec         = require('child_process').exec;                // Used to access bitmark-cli.
const fs           = require('fs');                                // Used to copy over the users default img.
const ROOT         = path.join(__dirname, '/../');                 // Server root path.
const LOGS_ROOT    = ROOT + 'logs/';                               // Bitmark root path.
const BITMARK_ROOT = ROOT + 'bitmark/';                            // Bitmark root path.
const API_ROOT     = ROOT + 'api/';                                // API root path.
const mongoose     = require('mongoose');                          // Our database.
const multer       = require('multer');                            // Express file upload middleware.
const request      = require('request')
//const TransactionsSchema = new mongoose.Schema({
//  "date": { type: Date, default: Date.now },
//  "txid": String,
//  "amount": Number,
//  "address": String,
//  "confirms": Number,
//}, { id: false });
// Beautiful hack to allow hotreloading when models already exists.
//const Transactions = mongoose.models.Transactions || mongoose.model('Transactions', TransactionsSchema)
//
// Will simplify later, sets up the uploaded files name and path multer middleware.
const storage      = multer.diskStorage({
  destination: (req, file, cb) => { cb(null, BITMARK_ROOT + 'uploads/') },
  filename: (req, file, cb) => {
    Users.findOne({"login-cookie": req.headers.cookie.split("login-cookie=")[1].split(';')[0] }, (err, user) => {
      if(err) return next(err);
      cb(null, user.username);
    })
  }
})
//
// BITMARK DATABASE CONNECT (MIGRATE TO ROBOT.BRAIN's REDDIS SERVER IN FUTURE!!!)
mongoose.Promise = global.Promise;
mongoose.connect('mongodb://localhost/bitmark-api', { useMongoClient: true })
  .then(() => console.log('[MONGOOSE] Connection succesful.'))
  .catch((err) => console.error("[MONGOOSE ERROR] " + err));
// Set up database.
const PostsSchema = new mongoose.Schema({
  "username": String,
  "marks": Number,
  "replyto": String,
  "ismarking": String,
  "message": String,
  "date": { type: Date, default: Date.now },
}, { id: false });
const UsersSchema = new mongoose.Schema({
  "username": String,
  "login-cookie": String,
  "password": String,
  "wallet": String,
  "balance": Number,
  "reputation": Number,
  "notifications": Array,
  updated_at: { type: Date, default: Date.now },
});
// Beautiful hack to allow hotreloading when models already exists.
const Users = mongoose.models.Users || mongoose.model('Users', UsersSchema)
const Posts = mongoose.models.Posts || mongoose.model('Posts', PostsSchema);
//
// MAIN
module.exports = (robot) => {
  // Server wide FavIcon
  robot.router.use(favicon(ROOT + 'public/favicon.ico'))
  robot.router.use("/", express.static(ROOT + 'public'))
  robot.router.use("/profile", express.static(ROOT + 'profile'))
//  var forge = require('node-forge')
//  var asn1 = forge.asn1
//  var pki = forge.pk
//  var webid = require('webid')('tls')
//  robot.router.get('/register', function (req, res) {
//    var ssl = require('ssl-utils')
//    ssl.generateCertBuffer(
//      'myCert',
//      false,
//      {subject: {CN:'leathan'}},
//      '/Users/leathan/Mubot/node_modules/hubot-server/credentials/privkey.pem',
//      '/Users/leathan/Mubot/node_modules/hubot-server/credentials/chain.pem',
//      function (err, key, cert, fingerprint, hash) {
//        var der = asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
//        res.set('Content-Type', 'application/x-x509-user-cert')
//        res.send(new Buffer(der, 'binary'))
//      }
//    );
//  })
//  _ = require('lodash')
//  webid = require('webid')
//  robot.router.get('/login', function(req, res){
//    try {
//      // Ask for user certificate
//      var certificate = req.socket.getPeerCertificate();
//      var certificate = req.connection.getPeerCertificate();
//      if (!_.isEmpty(certificate)) {
//        // If the user provite a certificate, verify it
//        var verifAgent = new webid.VerificationAgent(certificate);
//        verifAgent.verify(function (result) {
//          var foaf = new webid.Foaf(result);
//          req.session.profile = foaf.parse();
//          req.session.identified = true;
//          res.send('OK! Logged in!');
//        }, function(result) {
//          switch (result) {
//            case 'certificateProvidedSAN':
//              var message = 'No valide Certificate Alternative Name in your certificate';
//              break;
//            case 'profileWellFormed':
//              var message = 'Can\'t load your foaf file (RDF may not be valid)';
//              break;
//            case 'falseWebID':
//              var message = 'Your certificate public key is not the one of the FOAF file';
//              break;
//            case 'profileAllKeysWellFormed':
//              var message = "Missformed WebID";
//              break;
//            default:
//              var message = "Unknown WebID error";
//              break;
//          }
//        });
//      } else {
//        res.send("Certificate not provided");
//      }
//    } catch (e) {
//      sendError(res, e.message);
//    }
//  });
  // Logs
  robot.router.use("/logs", express.static(LOGS_ROOT + 'public'))
  robot.router.get("/logs", (req, res) => res.sendFile(LOGS_ROOT + 'logs.html'));
  robot.router.get("/logs/:server", (req, res) => res.sendFile(LOGS_ROOT + 'logs.html'));
  robot.router.get("/walletnotify/:coin/:txid", function(req, res) {
    exec(`bitmarkd getrawtransaction ${req.params.txid} 1`, (err, trans) => {
      try {
        trans = JSON.parse(trans.trim().replace(/(\n|\\)/g,''))
        for(var i=0; i<trans.vout.length; i++) {
          if ((index = robot.brain.data.keys['_'+req.params.coin].indexOf(trans.vout[i].scriptPubKey.addresses[0])) > -1) {
            user = robot.brain.data.keys[robot.brain.data.keys['_'+req.params.coin][index+1]]
            if(!trans.confirmations) break
            else if(user[req.params.coin].txids.indexOf(req.params.txid) > -1) break
            else {
              user[req.params.coin].txids.push(req.params.txid);
              user[req.params.coin].balance += parseFloat(trans.vout[i].value * 1000).toFixed(8);
              //console.log("Wallet notify script has just updated a users balance.");
            }
          }
        }
      } catch(e) { console.log("Error after wallet notify: " + e) }
    })
    res.end("Ok.")
  })
  // Post to discord.

  robot.router.get('/discord', (req, res) => {
    res.sendFile(ROOT + 'public/discord.html')
  });
  robot.router.post("/discord", (req, res) => {
    robot.messageRoom(req.body.channel, req.body.comment)
    res.writeHead(200, {'Content-Type': 'text/plain'})
    res.end("Your message has been sent, even if it doesn't feel that way.")
  })
  // Crypto API -> ATM Redirect main page here.
  robot.router.use("/api", express.static(API_ROOT + 'public'))
  robot.router.get(["/", "/api/gambling", "/api/crypto"], (req, res) => {
    res.sendFile(API_ROOT + 'api.html')
  })
  robot.router.get("/api", (req, res) => {
    var query = querystring.parse(req._parsedUrl.query)
    if (typeof query != 'undefined') {
      robot.emit("CryptoRequest", query, res)
    } else {
      res.sendFile(API_ROOT + 'api.html')
    }
  })
  robot.router.get("/ip", (req, res) => {
    res.writeHead(200, {'Content-Type': 'text/plain'})
    var ip;
    if (req.headers['x-forwarded-for']) {
      ip = req.headers['x-forwarded-for'].split(",")[0];
    } else if (req.connection && req.connection.remoteAddress) {
      ip = req.connection.remoteAddress;
    } else {
      ip = req.ip;
    }
    if(ip.toString().indexOf('127.0.0.1') > -1) res.end("Hi leathan")
    else res.end(ip)
  })
  // BITMARK
  robot.router.use("/bitmark", express.static(BITMARK_ROOT + 'public'))
  robot.router.use("/uploads", express.static(BITMARK_ROOT + 'uploads'))

  robot.router.post('/bitmark/uploads', multer({ storage: storage }).single('upl'), (req,res) => {
    res.sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  robot.router.get('/bitmark', (req, res, next) => {
//    if(req.cookies["login-cookie"]){
//      Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, post) => {
//        if (err) return next(err);
//        if (post) {
          res.sendFile(BITMARK_ROOT + 'bitmark.html')
//        } else res.sendFile(BITMARK_ROOT + 'index.html')
//      });
//    } else res.sendFile(BITMARK_ROOT + 'index.html')
  });
  /* GET /wallet */
  robot.router.get('/bitmark/wallet', (req, res, next) => {
    res.cookie("state", 'wallet').sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  /* GET /profile */
  robot.router.get('/bitmark/profile', (req, res, next) => {
    res.cookie("state", 'profile').sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  /* GET /other */
  //robot.router.get('/bitmark/other', (req, res, next) => {
  //  res.cookie("state", 'other', { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + 'bitmark.html');
  //});
  /* GET /users/:username */
  robot.router.get('/bitmark/users/:username', (req, res, next) => {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") }, (err, user) => {
      if (err) return next(err);
      if (user) { res.send("This is " + user.username + "'s profile. <br> They have " + user.balance + " marks.") }
      else { res.send("That user does not exist.") }
    });
  });
  /* POST /users/login */
  robot.router.post('/bitmark/users/login', (req, res, next) => {
    var login_cookie = randomstring.generate();
    Users.findOneAndUpdate({'username': new RegExp("^" + req.body.username + "$", "i"), 'password': req.body.password },  {"login-cookie": login_cookie },  (err, post) => {
      if (err) return next(err)
      if (post) res.cookie("login-cookie",login_cookie).end("") // Set their login cookie.
      else res.end("<h1>Error after finding user.</h1>")
    });
  });
  /* POST /users/createAccount */
  robot.router.post('/bitmark/users/createAccount', (req, res, next) => {
    Users.findOne({username: req.body.username }, (err, user) => {
      if (err) return next(err);
      if (user) { res.json({error: 'Username already exists.'}) }
      else {
        exec('bitmarkd getnewaddress', (error, stdout) => {
          req.body.wallet = stdout.trim();
          req.body.balance = 10;   // This is a temporary balance that im funding.
          req.body.reputation = 0; // For future use.
          Users.create(req.body, (err, post) => {
            fs.createReadStream(BITMARK_ROOT + 'public/images/default-user-image.png').pipe(fs.createWriteStream(BITMARK_ROOT + 'uploads/' + req.body.username));
            if (err) return next(err);
            res.json(post);
          });
        });
      }
    });
  });
  robot.router.get('/bitmark/post/:id', (req, res, next) => {
    res.cookie("state", req.params.id, { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + '/bitmark.html');
  });
  // API
  robot.router.get('/bitmark/reset', (req, res, next) => { // lets just hope no one reads this untill i remove it.
    Posts.deleteMany({},()=>{});
    Users.deleteMany({},()=>{});
    rs.json({});
  });
  robot.router.get('/bitmark/api/posts', (req, res, next) => {
    Posts.find((err, posts) => {
      if (err) return next(err);
      res.json(posts);
    });
  });
  robot.router.get('/bitmark/api/replies', (req, res, next) => {
    Posts.find({ "replyto": { $exists: true } }, (err, replies) => { if (err) return next(err); res.json(replies) })
  });
  robot.router.get('/bitmark/api/marks', (req, res, next) => {
    Posts.find({ "ismarking": { $exists: true } }, (err, markings) => { if (err) return next(err); res.json(markings) })
  });
  robot.router.get('/bitmark/api/post/:id', (req, res, next) => {
    Posts.findById(req.params.id, (err, post) => { res.json(post) })
  });
  robot.router.get('/bitmark/api/marks/:username', (req, res, next) => {
    Post.find({ "ismarking": req.params.username }, (err, markings) => { if (err) return next(err); res.json(markings) })
  });
  robot.router.get('/bitmark/api/info/:username', (req, res, next) => {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") }, (err, user) => {
      if (err) return next(err);
      if (user) {
        user.password = ""; user['login-cookie'] = ""; // Don't return the sensitive information via ajax response
        res.json(user);
      } else {
        res.json({error: "User doesn't exist"})
      }
    });
  });
  // API - Cookie needed
  robot.router.get('/bitmark/api/info', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, function (err, user) {
      if (user) {
        user.password = ""; user['login-cookie'] = ""; // Don't return the sensitive information via ajax response
        res.json(user)
      } else {
        // They are not logged in so send a stub.
        res.json({"_id":"Guest","username":"Guest","password":"","wallet":"","balance":0,"reputation":0,"__v":0,"login-cookie":"","updated_at":"","notifications":[]})
      }
    });
  });
  robot.router.post('/bitmark/api/mark', (req, res, next) => {
    Posts.findOne({"_id": req.body._id}, function (err, marked_post) {
      if (err) return next(err)
      Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, marking_user) => {
        if (!marking_user) return;                                                                                      // NOT LOGGED IN
        if (marking_user.balance < 1) return;                                                                           // NOT ENOUGH BALANCE
        createNotification({"_id": marked_post._id, "username": marked_post.username, "message": marked_post.message}); // CREATE NOTIFICATION
        Users.findByIdAndUpdate(marking_user._id,                    { $inc: { "balance": -1 } }, ()=>{});              // SUBTRACT BALANCE FROM SENDER
        Users.findOneAndUpdate({ "username": marked_post.username }, { $inc: { "balance":  1 } }, ()=>{});              // MARK POST
        Posts.findOneAndUpdate({ "_id": req.body._id },              { $inc: { "marks"  :  1 } }, ()=>{});              // ADD BALANCE TO RECEIVER
        Posts.create({"replyto": marked_post._id, "username": marking_user.username, "ismarking": marked_post.username, "message": req.body.marking_msg, "marks": 0 },
          (err, marking) => { if(err) return next(err); res.json(marking) }
        )
      })
    })
  });
  robot.router.get('/bitmark/api/delete_notification/:id', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, user) => {
      if (err) return next(err);
      Users.findOneAndUpdate({'username': user.username }, { $pull: { 'notifications': {'id': req.params.id.toString() } } }, { multi: true }, (e, user) => {
        res.json(user)
      })
    })
  });
  robot.router.post('/bitmark/api/create', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, creating_user) => {
      if (!creating_user) { res.json({error: "Not logged in."}); return; } // NOT LOGGED IN
      req.body.marks = 0;
      req.body.username = creating_user.username;
      Posts.create(req.body, (err, created_post) => {
        res.json(created_post);
        if (req.body.replyto) {
          Posts.findById(req.body.replyto, (err, post) => {
            if (post.username != creating_user.username) { createNotification(post) } // Dont create notification is user is replying to themselves
          })
        }
      })
    })
  });
  // catch 404 and forward to error handler
  robot.router.use((req, res, next) => {
    var err = new Error('Not Found Nigga');
    err.status = 404;
    res.send(
    '<h1>Not Found Nigga</h1>'
    );
    //next(err);
  });
  // error handler
  robot.router.use((err, req, res, next) => {
    // set locals, only providing error in development
    res.locals.message = err.message;
    res.locals.error = req.app.get('env') === 'development' ? err : {};
    // render the error page
    res.status(err.status || 500);
    res.send('<h1>Weird ass error yo</h1>');
  });
}
function createNotification(post) {
  var amount = 1; var index = -1; var found;
  Users.findOne({'username': post.username}, (err, user) => {
    user.notifications.forEach((n, i) => {
      if (n.id.toString() == post._id.toString()) { amount = n.amount + 1; found = i }
    });
    if (amount > 1) {
      var obj = {};
      obj["notifications."+found] = { 'id': post._id.toString(), 'message': post.message, 'amount': amount };
      Users.findOneAndUpdate({'username': post.username}, { $set: obj }, ()=>{});
    } else {
      Users.findOneAndUpdate({'username': post.username},
        { $push: { 'notifications': { 'id': post._id.toString(),  'message': post.message,  'amount': amount } } }, ()=>{})
    }
  })
}
