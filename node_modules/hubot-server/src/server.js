// Description:
//   An https server for hubot
//
// Requirements:
//   You must install express 4 and update robot.coffee accordingly

// INIT

const path         = require('path')
const express      = require('express')
const querystring  = require('querystring')
const favicon      = require('serve-favicon')

// BITMARK SPECIFIC INIT

const randomstring = require("randomstring");
const exec         = require('child_process').exec;
const fs           = require('fs');
const BITMARK_ROOT = path.join(__dirname, '/../bitmark')
const router       = express.Router()
const mongoose     = require('mongoose')
const multer       = require('multer');
const storage      = multer.diskStorage({
  destination: function (req, file, cb) { cb(null, BITMARK_ROOT + '/uploads/') },
  filename: function (req, file, cb) { 
    Users.findOne({"login-cookie": req.headers.cookie.split("login-cookie=")[1].split(';')[0] }, function (err, user) {
      cb(null, user.username)
    })
  }
})
const upload       = multer({ storage: storage });

// BITMARK DATABASE CONNECT (MIGRATE TO ROBOT.BRAIN's REDDIS SERVER IN FUTURE!!!)

mongoose.Promise = global.Promise;
mongoose.connect('mongodb://localhost/bitmark-api', { useMongoClient: true })
  .then(() => console.log('[MONGOOSE] Connection succesful.'))
  .catch((err) => console.error("[MONGOOSE] " + err));

const PostsSchema = new mongoose.Schema({ 
  "username": String,
  "marks": Number,
  "replyto": String,
  "ismarking": String,
  "message": String,
  "date": { type: Date, default: Date.now },
}, { id: false });
const UsersSchema = new mongoose.Schema({
  "username": String,
  "login-cookie": String,
  "password": String,
  "wallet": String,
  "balance": Number,
  "reputation": Number,
  "notifications": Array,
  updated_at: { type: Date, default: Date.now },
});
const Users = mongoose.model('Users', UsersSchema)
const Posts = mongoose.model('Posts', PostsSchema);

// MAIN

module.exports = function (robot) {
  robot.router.use(express.static(path.join(__dirname, '/../public')))
  robot.router.use(favicon(path.join(__dirname, '/../public/favicon.ico')))

  robot.router.get("/discord", function(req, res) {
    res.sendFile(path.resolve(__dirname + '/../public/html/discord.html')) 
  })
  robot.router.get(["/", "/api/gambling", "/api/crypto"], function(req, res) {
    res.sendFile(path.resolve(__dirname + '/../public/html/api.html')) 
  })
  robot.router.get("/api", function(req, res) {
    var query = querystring.parse(req._parsedUrl.query)
    if (typeof query != 'undefined') {
      robot.emit("CryptoRequest", query, res)
    } else {
      res.sendFile(path.resolve(__dirname + '/../public/html/api.html')) 
    }
  })
  robot.router.post("/discord", function (req, res) {
    robot.messageRoom(req.body.channel, req.body.comment)
    res.writeHead(200, {'Content-Type': 'text/plain'})
    res.end("Your message has been sent, even if it doesn't feel that way.")
  })

  // BITMARK

  robot.router.use("/bitmark", express.static(path.join(BITMARK_ROOT, '/public')))
  robot.router.use("/uploads", express.static(path.join(BITMARK_ROOT, '/uploads')))

  robot.router.post('/bitmark/uploads', upload.single('upl'), function(req,res){
    res.sendFile(BITMARK_ROOT + '/bitmark.html');
  });

  robot.router.get('/bitmark', function(req, res, next) {
    if(req.cookies["login-cookie"]){
      Users.findOne({"login-cookie": req.cookies["login-cookie"]}, function (err, post) {
        if (err) return next(err);
        if (post) {
          res.sendFile(path.resolve(BITMARK_ROOT + '/bitmark.html'))
        } else { res.sendFile(path.resolve(BITMARK_ROOT + 'index.html'));console.log(8) }
      });
    } else { res.sendFile(path.resolve(BITMARK_ROOT + '/index.html')); console.log(7) }
  });
  robot.router.get('/bitmark/wallet', function(req, res, next) {
    res.cookie("state", 'wallet', { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + '/bitmark.html');
  });
  router.get('/bitmark/profile', function(req, res, next) {
    res.cookie("state", 'profile', { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + '/bitmark.html');
  });
  router.get('/bitmark/other', function(req, res, next) {
    res.cookie("state", 'other', { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + '/bitmark.html');
  });


  /* GET /users/id */
  robot.router.get('/bitmark/users/:username', function(req, res, next) {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") }, function (err, user) {
      if (err) return next(err);
      if (user) { res.send("This is " + user.username + "'s profile. <br> They have " + user.balance + " marks.") }
      else { res.send("That user does not exist.") }
    });
  });
  /* POST /users/login */
  robot.router.post('/bitmark/users/login', function(req, res, next) {
    var login_cookie = randomstring.generate();
    Users.findOneAndUpdate({'username': new RegExp("^" + req.body.username + "$", "i"), 'password': req.body.password },  {"login-cookie": login_cookie },  function (err, post) {
      if (err) return next(err)
      if (post) res.cookie("login-cookie",login_cookie).end("")
      else res.end("ERROR")
    });
  });
  /* POST /users */
  robot.router.post('/bitmark/users/createAccount', function(req, res, next) {
    exec('bitmarkd getnewaddress', function(error, stdout) {
      req.body.wallet = stdout.trim();
      req.body.balance = 10;
      req.body.reputation = 0;
      Users.create(req.body, function (err, post) {
        fs.createReadStream(path.join(BITMARK_ROOT, '/public/images/default-user-image.png')).pipe(fs.createWriteStream(path.join(BITMARK_ROOT, '/uploads/' + req.body.username)));
        if (err) return next(err);
        res.json(post);
      });
    });
  });

  // API

  robot.router.get('/bitmark/posts/:id', function(req, res, next) {
    res.cookie("state", req.params.id, { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + '/bitmark.html');
  });
  robot.router.get('/bitmark/reset', function(req, res, next) {
    Posts.deleteMany({},function(){});
    Users.deleteMany({},function(){});
  });
  robot.router.get('/bitmark/posts', function(req, res, next) {
    Posts.find(function (err, posts) {
      if (err) return next(err);
      res.json(posts);
    });
  });
  robot.router.get('/bitmark/api/replies', function(req, res, next) {
    Posts.find({ "replyto": { $exists: true } }, function (err, replies) { res.json(replies) })
  });
  robot.router.get('/bitmark/api/markings', function(req, res, next) {
    Posts.find({ "ismarking": { $exists: true } }, function (err, markings) { res.json(markings) })
  });
  robot.router.get('/bitmark/api/post/:id', function(req, res, next) {
    Posts.findById(req.params.id, function (err, post) { res.json(post) })
  });
  robot.router.get('/bitmark/api/markings/:username', function(req, res, next) {
    Post.find({ "ismarking": req.params.username }, function (err, markings) { res.json(markings) })
  });
  robot.router.get('/bitmark/info', function(req, res, next) {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, function (err, user) {
      if (user) {
        user.password = ""; user['login-cookie'] = ""; // Don't return the sensitive information via ajax response
        res.json(user)
      }
    })
  });
  robot.router.get('/bitmark/api/info/:username', function(req, res, next) {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") }, function (err, user) {
      if (err) return next(err);
      user.password = ""; user['login-cookie'] = ""; // Don't return the sensitive information via ajax response
      res.json(user);
    })
  });
  robot.router.post('/bitmark/mark', function(req, res, next) {
    Posts.findOne({"_id": req.body._id}, function (err, marked_post) {
      Users.findOne({"login-cookie": req.cookies["login-cookie"]}, function (err, marking_user) {
        if (!marking_user) return;                                                                                      // NOT LOGGED IN
        if (marking_user.balance < 1) return;                                                                           // NOT ENOUGH BALANCE
        createNotification({"_id": marked_post._id, "username": marked_post.username, "message": marked_post.message}); // CREATE NOTIFICATION
        Users.findByIdAndUpdate(marking_user._id,                    { $inc: { "balance": -1 } }, function () {});      // SUBTRACT BALANCE FROM SENDER
        Users.findOneAndUpdate({ "username": marked_post.username }, { $inc: { "balance":  1 } }, function () {});      // MARK POST
        Posts.findOneAndUpdate({ "_id": req.body._id },              { $inc: { "marks"  :  1 } }, function () {});      // ADD BALANCE TO RECEIVER
        Posts.create(
          {"replyto": marked_post._id, "username": marking_user.username, "ismarking": marked_post.username, "message": req.body.marking_msg, "marks": 0 },
          function (err, marking) { res.json(marking) }
        )
      })
    })
  });
  robot.router.get('/bitmark/delete_notification/:id', function(req, res, next) {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, function (err, user) {
      if (err) return next(err);
      Users.findOneAndUpdate({'username': user.username }, { $pull: { 'notifications': {'id': req.params.id.toString() } } }, { multi: true }, function(e, user) {
        res.json(user)
      })
    })
  });
  robot.router.post('/bitmark/create', function(req, res, next) {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, function (err, creating_user) {
      if (!creating_user) return; // NOT LOGGED IN
      req.body.marks = 0;
      req.body.username = creating_user.username;
      Posts.create(req.body, function (err, created_post) {
        res.json(created_post);
        if (req.body.replyto) {
          Posts.findById(req.body.replyto, function (err, post) {
            if (post.username != creating_user.username) { createNotification(post) } // Dont create notification is user is replying to themselves
          })
        }
      })
    })
  });
  function createNotification(post) {
    var amount = 1; var index = -1; var found;
    Users.findOne({'username': post.username}, function(err, user) {
      user.notifications.forEach(function(n, i){
        if (n.id.toString() == post._id.toString()) { amount = n.amount + 1; found = i }
      });
      if (amount > 1) {
        var obj = {};
        obj["notifications."+found] = { 'id': post._id.toString(), 'message': post.message, 'amount': amount };
        Users.findOneAndUpdate({'username': post.username}, { $set: obj }, function () {});
      } else {
        Users.findOneAndUpdate({'username': post.username},
          { $push: { 'notifications': { 'id': post._id.toString(),  'message': post.message,  'amount': amount } } }, function () {})
      }
    })
  }
  // catch 404 and forward to error handler
  robot.router.use(function(req, res, next) {
    var err = new Error('Not Found Nigga');
    err.status = 404;
    res.send(
    '<h1>Not Found Nigga</h1>'
    );
    //next(err); 
  });
  // error handler
  robot.router.use(function(err, req, res, next) {
    // set locals, only providing error in development
    res.locals.message = err.message;
    res.locals.error = req.app.get('env') === 'development' ? err : {};
    // render the error page
    res.status(err.status || 500);
    res.send('Some weird error');
  });
}
