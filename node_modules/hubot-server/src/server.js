// Description:
//   An https server for hubot
//
// Requirements:
//   You must install express 4 and update bot.coffee accordingly (this is done automatically with mubot)
//
// INIT
const path         = require('path');                              // Used for cross platform file system support.
const querystring  = require('querystring');                       // Handy for parsing urls.
const favicon      = require('serve-favicon') ;                    // Favicon middlerware for express.
// BITMARK SPECIFIC INIT
const express      = require('express');                           // Used for setting up static directories.
const randomstring = require("randomstring");                      // Used for cookie generation.
const exec         = require('child_process').exec;                // Used to access bitmark-cli.
const fs           = require('fs');                                // Used to copy over the users default img.
const ROOT         = path.join(__dirname, '/../');                 // Server root path.
const LOGS_ROOT    = ROOT + 'logs/';                               // Bitmark root path.
const BITMARK_ROOT = ROOT + 'bitmark/';                            // Bitmark root path.
const API_ROOT     = ROOT + 'api/';                                // API root path.
const mongoose     = require('mongoose');                          // Our database.
const multer       = require('multer');                            // Express file upload middleware.
const request      = require('request')
//const TransactionsSchema = new mongoose.Schema({
//  "date": { type: Date, default: Date.now },
//  "txid": String,
//  "amount": Number,
//  "address": String,
//  "confirms": Number,
//}, { id: false });
// Beautiful hack to allow hotreloading when models already exists.
//const Transactions = mongoose.models.Transactions || mongoose.model('Transactions', TransactionsSchema)
//
// Will simplify later, sets up the uploaded files name and path multer middleware.
const storage      = multer.diskStorage({
  destination: (req, file, cb) => { cb(null, BITMARK_ROOT + 'uploads/') },
  filename: (req, file, cb) => {
    Users.findOne({"login-cookie": req.headers.cookie.split("login-cookie=")[1].split(';')[0] }, (err, user) => {
      if(err) return next(err);
      cb(null, user.username);
    })
  }
})
//
// BITMARK DATABASE CONNECT (MIGRATE TO bot.BRAIN's REDDIS SERVER IN FUTURE!!!)
mongoose.Promise = global.Promise;
mongoose.connect('mongodb://localhost/bitmark-api', { useMongoClient: true })
  .then(() => console.log('[MONGOOSE] Connection succesful.'))
  .catch((err) => console.error("[MONGOOSE ERROR] " + err));
// Set up database.
const PmsSchema = new mongoose.Schema({
  "sender": String,
  "receiver": String,
  "ismarked": Number,
  "message": String,
  "date": { type: Date, default: Date.now },
});
const PostsSchema = new mongoose.Schema({
  "username": String,
  "marks": Number,
  "replyto": String,
  "replyto_user": String,
  "ismarking": Number,
  "message": String,
  "date": { type: Date, default: Date.now },
}, { id: false });
const UsersSchema = new mongoose.Schema({
  "username": String,
  "login-cookie": String,
  "password": String,
  "wallet": String,
  "balance": Number,
  "reputation": Number,
  "notifications": Array,
  "private_messages": Array,
  "awaiting_pm": Object,
  updated_at: { type: Date, default: Date.now },
});
// Beautiful hack to allow hotreloading when models already exists.
const Users = mongoose.models.Users || mongoose.model('Users', UsersSchema);
const Posts = mongoose.models.Posts || mongoose.model('Posts', PostsSchema);
const Pms   = mongoose.models.Pms   || mongoose.model('Pms',   PmsSchema);
//
// MAIN
module.exports = bot => {
  const io = bot.io.bitmark = bot.io.of('/bitmark');
  // Server wide FavIcon
  bot.router.use(favicon(ROOT + 'public/favicon.ico'))
  bot.router.use("/", express.static(ROOT + 'public'))
  bot.router.use("/profile", express.static(ROOT + 'profile'))
  bot.router.get("/chat", (req, res) => res.sendFile(ROOT + 'public/io.html'));
  bot.router.use("/logs", express.static(LOGS_ROOT + 'public'))
  bot.router.get("/logs", (req, res) => res.sendFile(LOGS_ROOT + 'logs.html'));
  bot.router.get("/logs/:server", (req, res) => res.sendFile(LOGS_ROOT + 'logs.html'));
  bot.router.get("/walletnotify/:coin/:txid", function(req, res) {
    exec(`bitmarkd getrawtransaction ${req.params.txid} 1`, (err, trans) => {
      try {
        trans = JSON.parse(trans.trim().replace(/(\n|\\)/g,''))
        for(var i=0; i<trans.vout.length; i++) {
          if ((index = bot.brain.data.keys['_'+req.params.coin].indexOf(trans.vout[i].scriptPubKey.addresses[0])) > -1) {
            user = bot.brain.data.keys[bot.brain.data.keys['_'+req.params.coin][index+1]]
            if(!trans.confirmations) break
            else if(user[req.params.coin].txids.indexOf(req.params.txid) > -1) break
            else {
              user[req.params.coin].txids.push(req.params.txid);
              user[req.params.coin].balance += parseFloat(trans.vout[i].value * 1000).toFixed(8);
              //console.log("Wallet notify script has just updated a users balance.");
            }
          }
        }
      } catch(e) { res.end(0); console.log("Error after wallet notify: " + e) }
    })
    res.end("Ok.")
  })
  // Post to discord.
  bot.router.get('/discord', (req, res) => {
    res.sendFile(ROOT + 'public/discord.html')
  });
  bot.router.post("/discord", (req, res) => {
    bot.messageRoom(req.body.channel, req.body.comment)
    //res.writeHead(200, {'Content-Type': 'text/plain'})
    res.end("Your message has been sent.")
  })
  // Crypto API -> ATM Redirect main page here.
  bot.router.use("/api", express.static(API_ROOT + 'public'))
  bot.router.get(["/", "/api/gambling", "/api/crypto"], (req, res) => {
    res.sendFile(API_ROOT + 'api.html')
  })
  bot.router.get("/api", (req, res) => {
    var query = querystring.parse(req._parsedUrl.query)
    if (query) {
      bot.emit("CryptoRequest", query, res)
    } else {
      res.sendFile(API_ROOT + 'api.html')
    }
  })
  bot.router.get("/ip", (req, res) => {
    res.writeHead(200, {'Content-Type': 'text/plain'})
    var ip;
    if (req.headers['x-forwarded-for']) {
      ip = req.headers['x-forwarded-for'].split(",")[0];
    } else if (req.connection && req.connection.remoteAddress) {
      ip = req.connection.remoteAddress;
    } else {
      ip = req.ip;
    }
    if(ip.toString().includes('127.0.0.1')) res.end("Hi leathan")
    else res.end(/(\d{1,3}\..*)/.exec(ip)[1] || "Idk")
  })
  // BITMARK
  bot.router.use("/bitmark", express.static(BITMARK_ROOT + 'public'))
  bot.router.use("/uploads", express.static(BITMARK_ROOT + 'uploads'))

  bot.router.post('/bitmark/uploads', multer({ storage: storage }).single('upl'), (req,res) => {
    res.sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  bot.router.get('/bitmark', (req, res, next) => {
     res.sendFile(BITMARK_ROOT + 'bitmark.html')
  });
  /* GET /wallet */
  bot.router.get('/bitmark/wallet', (req, res, next) => {
    res.cookie("state", 'wallet').sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  /* GET /profile */
  bot.router.get('/bitmark/profile', (req, res, next) => {
    res.cookie("state", 'profile').sendFile(BITMARK_ROOT + 'bitmark.html');
  });
  /* GET /users/:username */
  bot.router.get('/bitmark/users/:username', (req, res, next) => {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") }, (err, user) => {
      if (err) return next(err);
      if (user) { res.send("This is " + user.username + "'s profile. <br> They have " + user.balance + " marks.") }
      else { res.send("That user does not exist.") }
    });
  });
  /* POST /users/login */
  bot.router.post('/bitmark/users/login', (req, res, next) => {
    var login_cookie = randomstring.generate();
    Users.findOneAndUpdate({'username': new RegExp("^" + req.body.username + "$", "i"), 'password': req.body.password },  {"login-cookie": login_cookie },  (err, post) => {
      if (err) return next(err)
      if (post) res.cookie("login-cookie",login_cookie).end("") // Set their login cookie.
      else res.end("ERROR")
    });
  });
  /* POST /users/createAccount */
  bot.router.post('/bitmark/users/createAccount', (req, res, next) => {
    Users.findOne({username: req.body.username }, (err, user) => {
      if (err) return next(err);
      if (user) { res.json({error: 'Username already exists.'}) }
      else {
        exec('bitmarkd getnewaddress', (error, stdout) => {
          req.body.wallet = stdout.trim();
          req.body.balance = 10;   // This is a temporary balance that im funding.
          req.body.reputation = 0; // For future use.
          req.body.private_messages = [];
          req.body.awaiting_pms = [];
          Users.create(req.body, (err, post) => {
            fs.createReadStream(BITMARK_ROOT + 'public/images/default-user-image.png').pipe(fs.createWriteStream(BITMARK_ROOT + 'uploads/' + req.body.username));
            if (err) return next(err);
            res.json(post);
          });
        });
      }
    });
  });
  bot.router.get('/bitmark/post/:id', (req, res, next) => {
    res.cookie("state", req.params.id).sendFile(BITMARK_ROOT + '/bitmark.html');
    //res.cookie("state", req.params.id, { expires: new Date(Date.now() + 9000000) }).sendFile(BITMARK_ROOT + '/bitmark.html');
  });
  // API
  //bot.router.get('/bitmark/reset', (req, res, next) => { // lets just hope no one reads this untill i remove it.
  //  Posts.deleteMany({},()=>{});
  //  Users.deleteMany({},()=>{});
  //  res.json({});
  //});
  bot.router.get('/bitmark/reset', (req, res, next) => { // lets just hope no one reads this untill i remove it.
    Users.findOneAndUpdate({ username: 'leathan' }, { $set: { notifications: [] } }, function(err, user){
      res.json({});
    });
  });
  bot.router.get('/bitmark/api/posts', (req, res, next) => {
     Posts.find({}).exec((err, posts) => res.json(posts || {}));
     //.sort({'date': -1})
  });
  bot.router.get('/bitmark/api/replies', (req, res, next) => {
    Posts.find({ "replyto": { $exists: true } }, (err, replies) => res.json(replies || {}))
  });
  bot.router.get('/bitmark/api/marks', (req, res, next) => {
    Posts.find({ "ismarking": { $exists: true } }, (err, markings) => res.json(markings || {}))
  });
  bot.router.get('/bitmark/api/post/:id', (req, res, next) => {
    Posts.findById(req.params.id, (err, post) => { res.json(post || {}) })
  });
  bot.router.get('/bitmark/api/marks_received/:username', (req, res, next) => {
    Post.find({ "ismarking": { $exists: true },  "replyto_user": req.params.username }, (err, markings) => res.json(markings || {}))
  });
  bot.router.get('/bitmark/api/marks_given/:username', (req, res, next) => {
    Post.find({ "username": req.params.username, "ismarking": { $exists: true } }, (err, markings) => res.json(markings || {}))
  });
  bot.router.get('/bitmark/api/info/:username', (req, res, next) => {
    Users.findOne({username: new RegExp("^" + req.params.username + "$", "i") },
    // Don't return the sensitive information via ajax response
    {'awaiting_pm': false, 'password': false, 'login-cookie': false, 'notifications': false},
    (err, user) => {
      res.json(user || {error: "User doesn't exist"})
    });
  });
  // API - Cookie needed
  bot.router.get('/bitmark/api/info', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, {'password': false, 'login-cookie':false}, function (err, user) {
      if (user) {
        res.json(user)
      } else {
        // They are not logged in so send a stub.
        res.json({"username":"Guest","wallet":"","balance":0,"reputation":0,"updated_at":"","notifications":[],"private_messages":[]})
     }
    });
  });
  bot.router.post('/bitmark/api/mark', (req, res, next) => {
    Posts.findOne({"_id": req.body._id}, function (err, marked_post) {
      if (err) return res.end(err)
      Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, marking_user) => {
        if (!marking_user || marking_user.balance < 1) return;  // NOT LOGGED IN / NOT ENOUGH FUNDS
        createNotification(marked_post.toJSON());  // CREATE NOTIFICATION
        // SUBTRACT BALANCE FROM SENDER
        Users.findByIdAndUpdate( marking_user._id, { $inc: { "balance": -1 } }, ()=>{
          if(usersOnline[marking_user.username]) usersOnline[marking_user.username].balance++
        });
        // Add balance to receiver
        Users.findOneAndUpdate({ "username": marked_post.username }, { $inc: { "balance": 1 } }, ()=>{
          if(usersOnline[marked_post.username]) usersOnline[marked_post.username].balance++
        });
        Posts.findOneAndUpdate({ "_id": req.body._id }, { $inc: { "marks" : 1 } }, ()=>{});      // MARK POST
        Posts.create({"replyto_user": marked_post.username, "replyto": marked_post._id, "username": marking_user.username, "ismarking": 1, "message": req.body.marking_msg, "marks": 0 },
        (err, marking) => {
          if(err) return res.end(err);
          io.emit("new post", marking)
          res.json(marking)
        })
      })
    })
  });
  bot.router.get('/bitmark/api/delete_notification/:id', (req, res, next) => {
   Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, user) => {
    if (err) return res.end(err);
      Users.findOneAndUpdate({'username': user.username }, { $pull: { 'notifications': {'id': req.params.id.toString() } } }, { multi: true }, (e, user) => {
        res.json(user)
      })
    })
  });
  bot.router.post('/bitmark/api/create', (req, res, next) => {
    Users.findOne({"login-cookie": req.cookies["login-cookie"]}, (err, creating_user) => {
      if (!creating_user) { res.json({error: "Not logged in."}); return; } // NOT LOGGED IN
      req.body.marks = 0;
      req.body.username = creating_user.username;
      if (req.body.replyto) {
        Posts.findById(req.body.replyto, (err, post) => {
          req.body.replyto_user = post.username;
          createPost(req.body)
          if (post.username !== creating_user.username) { createNotification(post.toJSON()) } // Dont create notification is user is replying to themselves
        })
      } else createPost(req.body)
      function createPost(post) {
        Posts.create(post, (err, created_post) => {
          if(err) return res.end(err)
          io.emit("new post", created_post)
          res.json(created_post);
        })
      }
    })
  });
  function logOut(user) {
    Users.findOneAndUpdate({'username': user }, { 'login-cookie': 'logged-out' }, (err, user) => {
      delete logged[user['login-cookie']]
    })
    io.sockets.users[user].broadcast.emit("user logged out", user);
    delete usersOnline[user]
    delete io.sockets.users[user]
  }
  // Save every users socket, by user.
  io.sockets.users = {};
  const usersOnline = {}, logged = {};
  function isLoggedIn(socket, cb) {
    if(socket.handshake.headers.cookie) {
      let cookie;
      if(cookie = /login-cookie=(\w{32})/.exec(socket.handshake.headers.cookie)) cookie = cookie[1];
      else return cb(false)
      if(logged[cookie]) {
        io.sockets.users[logged[cookie]] = socket;
        return cb(logged[cookie]);
      }
      // If this is our first time seeing the user, query database and build shortcut hashes.
      Users.findOne({ "login-cookie": cookie }, (err, user) => {
        if(err) throw new Error('Error @ Users.findOne({ "login-cookie": cookie }, (err, user) => {');
        if(!user) return cb(false); // Bad cookie.
        let cleanedUser = {
          balance:    user.balance,
          username:   user.username,  // make sure sensitive info isn't sent.
          reputation: user.reputation,
          updated_at: user.updated_at
        }
        io.emit("user logged in", cleanedUser)
        logged[cookie] = user.username;
        usersOnline[user.username] = cleanedUser; // shortcut hashes
        io.sockets.users[user.username] = socket;
        cb(user.username);
      })
    } else {
      cb(false);
      // Guest logged in - out.
    }
  }
  io.on("connection", socket => {
    //socket.on("disconnect", socket => updateLoggedIn(socket, false)); This event is fired on refresh...
    isLoggedIn(socket, username => {
      if(!username) return; // Its a guest.
      socket.on("log out", () => {
        logOut(username)
        socket.broadcast.emit("user logged out", username);
      });
      socket.on("private message open", pm => {
        if(pm.maximized) pmRead(pm)
        // dont log history for now..
        pm.history = [];
        if(pm.exists) delete pm.exists
        else Users.findOneAndUpdate({ "username": username }, { $push: { "private_messages": pm } }, (err, user)=>{
          console.log(pm.username + "'s private message opened or loaded by " + username + ".")
        });
        //else Users.findOneAndUpdate({ "username": username, "private_messages.username": pm.username  }, { $set: { "private_messages.$": pm } }, (err, user)=>{console.log(user)});
        getPms(username, pm.username, pms => {
          socket.emit("private message data", pms)
        })
      })
      socket.on("mark private message", (pm, cb) => markPm(username, pm, cb));
      socket.on("new private message", pm => {
        if(io.sockets.users[pm.username]) io.sockets.users[pm.username].emit("private_messages typing", { user: username, finished: true })
        createPm(username, pm, processedPm => {
          socket.emit("new private message", processedPm);
          if(io.sockets.users[processedPm.receiver]) io.sockets.users[processedPm.receiver].emit("new private message", processedPm);
        });
      })
      socket.on("private message toggle", pm => {
        if(pm.maximized) pmRead(pm)
        pm.history = [];
        var data = "private_messages.username" + pm.username;
        Users.findOneAndUpdate({ "username": username, "private_messages.username": pm.username  }, { $set: { "private_messages.$": pm } }, (err, user) => {
          console.log(pm.username + "'s private message toggled by " + username + ". PM.MAXIMIZED: " + pm.maximized)
        });
      })
      function pmRead(pm) {
        var field = "awaiting_pm" + "." + pm.username;
        Users.findOneAndUpdate({ "username": username }, { $unset: {[field]:1} }, {returnNewDocument: true}, (err, user)=> {
          console.log(pm.username + "'s private message read by " + username + ".")
        })
      }
      socket.on("private message close", pm => {
        Users.findOneAndUpdate({ "username": username }, { $pull: { private_messages: { "username": pm.username } } }, (err, user) => {
          console.log(pm.username + "'s private message closed by " + username + ".")
        });
      })
      socket.on("private_messages typing", data => {
        if(io.sockets.users[data.user]) io.sockets.users[data.user].emit("private_messages typing", {user: username})
      })
    });
    socket.on("users online", () => socket.emit("users online", usersOnline))
  })
  // catch 404 not found
  bot.router.use((req, res, next) => {
    res.end('<h1>Not Found Dawg</h1>');
  });
  // error handler
  bot.router.use((err, req, res, next) => {
    //res.locals.message = err.message;
    //res.locals.error = req.app.get('env') === 'development' ? err : {};
    res.status(err.status || 500);
    res.end('<h1>Weird Error Yo</h1>');
  });

  function getPms(user, withUser, cb, amount) {
    amount = amount || 100;
    Pms.find({ $or:[ {sender: user, receiver: withUser}, {sender: withUser, receiver: user} ]}).sort({'date': 1}).limit(amount).exec((err, pms) => {
      console.log(withUser + "'s private messages loaded by " + user + ".")
      cb(pms || {})
    });
  }

  function markPm(user, pm, cb) {
    if(pm.ismarked || user === pm.sender || usersOnline[user].balance < 1) return cb(false);
    Pms.findOneAndUpdate(pm, {ismarked: 1}, (err, pm) => {
      if(err || !pm) return cb(false);
      Users.findOneAndUpdate({ "username": user }, { $inc: { "balance": -1 } }, ()=>{if(usersOnline[user]) usersOnline[user].balance++});
      Users.findOneAndUpdate({ "username": pm.sender }, { $inc: { "balance": 1 } }, ()=>{if(usersOnline[user]) usersOnline[user].balance++});
      Posts.create({"replyto": pm._id.toString(), "replyto_user": pm.sender, "username": user, "ismarking": 1, "marks": 0 }, (err, marking)=>{
        io.emit("new post", marking)
      })
      cb(!!pm)
    })
  }

  function createPm(sender, pmData, cb) {
    var pm = {}
    pm.sender = sender;
    pm.receiver = pmData.username;
    pm.message = pmData.message;
    Pms.create(pm, (err, pm) => {
      var field = "awaiting_pm" + "." + sender;
      Users.findOneAndUpdate({ "username": 'leathan', "$or": [{"private_messages.username": {$not: /^dude$/ } }, {"private_messages.maximized": false }] },
                             { "$inc": { "awaiting_pm.dude": 1 } }, {returnNewDocument:true}).then((e,u)=>{
        if(!u) console.log(pmData.username + " is not awaiting " + sender + "'s pm because he has that window open.")
        else console.log(sender + "'s pm is awaited by " + pmData.username + ".")
      })
      cb(pm || {})
    })
  }

  function createNotification(post) {
    notification = {
      id: post._id.toString(),
      amount: 1, // Amount of notifications per post.
      message: post.message
    }
    Users.findOne({'username': post.username}, (err, user) => {
      var found = 0;
      for(let i = 0, l = user.notifications.length; i < l; i++) {
        let n = user.notifications[i];
        if (n.id === notification.id) { notification.amount = n.amount + 1; found = i }
      };
      // A post has receiced anther notification.
      if (notification.amount > 1) {
        let obj = {};
        // The dot notation here is mongoose specific meaning notifications[found]. Its NOT a hash obj.
        obj['notifications.' + found] = notification;
        Users.findOneAndUpdate({'username': post.username}, {$set: obj}, {returnNewDocument: true}, (err, user) => {
          //try { io.sockets.users[post.username].emit("new notification", notification) }
          //catch(e) {} // They arn't logged on do nothing
        });
      }
      // New post notification
      else {
        Users.findOneAndUpdate({'username': post.username}, { $push: { 'notifications': notification } }, {returnNewDocument: true}, (err, user) => {
          //try { io.sockets.users[post.username].emit("new notification", notification) }
          //catch(e) {} // They arn't logged on do nothing
        })
      }
    })
  }
}
