/*(function(window) {
      return
    }
    if (this._tab.mode === leatMine.FORCE_EXCLUSIVE_TAB) {
      this._tab.grace = Date.now() + 3e3
    }
    if (!this.verifyThread) {
      this.verifyThread = new leatMine.JobThread
    }
    this.setNumThreads(this._targetNumThreads);
    this._autoReconnect = true;
    if (leatMine.CONFIG.REQUIRES_AUTH && !this._optInToken) {
      this._waitingForAuth = true;
      this._auth.auth(function(token) {
        this._waitingForAuth = false;
        if (!token) {
          this.stop();
          this._emit("optin", {
            status: "canceled"
          });
          this._emit("error", {
            error: "opt_in_canceled"
          });
          return
        }
        this._emit("optin", {
          status: "accepted"
        });
        this._optInToken = token;
        this._connect()
      }
      .bind(this))
    } else {
      this._connect()
    }
  }
  ;
  Miner.prototype._otherTabRunning = function() {
    if (this._tab.lastPingReceived > Date.now() - 1500) {
      return true
    }
    try {
      var tdjson = localStorage.getItem("leatmine");
      if (tdjson) {
        var td = JSON.parse(tdjson);
        if (td.ident !== this._tab.ident && Date.now() - td.time < 1500) {
          return true
        }
      }
    } catch (e) {}
    return false
  }
  ;
  Miner.prototype._updateTabs = function() {
    var otherTabRunning = this._otherTabRunning();
    if (otherTabRunning && this.isRunning() && Date.now() > this._tab.grace) {
      this.stop("dontKillTabUpdate")
    } else if(!otherTabRunning && !this.isRunning()) {
      this._startNow()
    }
    if(this.isRunning() && !this._waitingForAuth) {
      if (this._bc) {
        this._bc.postMessage("ping")
      }
      try {
        localStorage.setItem("leatmine", JSON.stringify({
          ident: this._tab.ident,
          time: Date.now()
        }))
      } catch (e) {}
    }
  }
  ;
  Miner.prototype._adjustThreads = function() {
    var hashes = this.getHashesPerSecond();
    var threads = this.getNumThreads();
    var stats = this._autoThreads.stats;
    stats[threads] = stats[threads] ? stats[threads] * .5 + hashes * .5 : hashes;
    if (Date.now() > this._autoThreads.adjustAt) {
      this._autoThreads.adjustAt = Date.now() + this._autoThreads.adjustEvery;
      var cur = (stats[threads] || 0) - 1;
      var up = stats[threads + 1] || 0;
      var down = stats[threads - 1] || 0;
      if (cur > down && (up === 0 || up > cur) && threads < 8) {
        return this.setNumThreads(threads + 1)
      } else if (cur > up && (!down || down > cur) && threads > 1) {
        return this.setNumThreads(threads - 1)
      }
    }
  }
  ;
  Miner.prototype._emit = function(type, params) {
    var listeners = this._eventListeners[type];
    if (listeners && listeners.length) {
      for (var i = 0; i < listeners.length; i++) {
        listeners[i](params)
      }
    }
  }
  ;
  Miner.prototype._hashString = function(s) {
    var hash = 5381
      , i = s.length;
    while (i) {
      hash = hash * 33 ^ s.charCodeAt(--i)
    }
    return hash >>> 0
  }
  ;
  Miner.prototype._connect = function() {
    if (this._socket) {
      return
    }
    var shards = leatMine.CONFIG.WEBSOCKET_SHARDS;
    var shardIdx = this._hashString(this._siteKey) % shards.length;
    var proxies = shards[shardIdx];
    var proxyUrl = proxies[Math.random() * proxies.length | 0];
    this._socket = new WebSocket(proxyUrl);
    this._socket.onmessage = this._onMessage.bind(this);
    this._socket.onerror = this._onError.bind(this);
    this._socket.onclose = this._onClose.bind(this);
    this._socket.onopen = this._onOpen.bind(this)
  }
  ;
  Miner.prototype._onOpen = function(ev) {
    this._emit("open");
    var params = {
      site_key: this._siteKey,
      type: "anonymous",
      user: null,
      goal: 0
    };
    if(this._user) {
      params.type = "user";
      params.user = this._user.toString()
    } else if (this._goal) {
      params.type = "token";
      params.goal = this._goal
    }
    if(this._optInToken) {
      params.opt_in = this._optInToken
    }
    this._send("auth", params)
  }
  ;
  Miner.prototype._onError = function(ev) {
    this._emit("error", {
      error: "connection_error"
    });
    this._onClose(ev)
  }
  ;
  Miner.prototype._onClose = function(ev) {
    if (ev.code >= 1003 && ev.code <= 1009) {
      this._reconnectRetry = 60
    }
    for (var i = 0; i < this._threads.length; i++) {
      this._threads[i].stop()
    }
    this._threads = [];
    this._socket = null;
    this._emit("close");
    if(this._autoReconnect) {
      setTimeout(this._startNow.bind(this), this._reconnectRetry * 1000)
    }
  }
  ;
  Miner.prototype._onMessage = function(ev) {
    var msg = JSON.parse(ev.data);
    if (msg.type === "job") {
      this._setJob(msg.params);
      this._emit("job", msg.params);
      if (this._autoThreads.enabled && !this._autoThreads.interval) {
        this._autoThreads.adjustAt = Date.now() + this._autoThreads.adjustEvery;
        this._autoThreads.interval = setInterval(this._adjustThreads.bind(this), 1e3)
      }
    } else if (msg.type === "verify") {
      this.verifyThread.verify(msg.params, this._onVerifiedBound)
    } else if (msg.type === "hash_accepted") {
      this._hashes = msg.params.hashes;
      this._emit("accepted", msg.params);
      if (this._goal && this._hashes >= this._goal) {
        this.stop()
      }
    } else if (msg.type === "authed") {
      this._tokenFromServer = msg.params.token || null;
      this._hashes = msg.params.hashes || 0;
      this._emit("authed", msg.params);
      this._reconnectRetry = 3
    } else if (msg.type === "error") {
      if (console && console.error) {
        console.error("leatMine Error:", msg.params.error)
      }
      this._emit("error", msg.params);
      if (msg.params.error === "invalid_site_key") {
        this._reconnectRetry = 6000
      } else if(msg.params.error === "invalid_opt_in") {
        if(this._stopOnInvalidOptIn) {
          return this.stop()
        } else if(this._auth) {
          this._auth.reset()
        }
      }
    } else if(msg.type === "banned" || msg.params.banned) {
      this._emit("error", {
        banned: true
      });
      this._reconnectRetry = 600
    }
  }
  ;
  Miner.prototype._setJob = function(job) {
    this._currentJob = job;
    this._currentJob.throttle = this._throttle;
    for (var i = 0; i < this._threads.length; i++) {
      this._threads[i].setJob(job, this._onTargetMetBound)
    }
  }
  ;
  Miner.prototype._onTargetMet = function(result) {
    this._emit("found", result);
    if(result.job_id === this._currentJob.job_id) {
      this._send("submit", {
        job_id: result.job_id,
        nonce: result.nonce,
        result: result.result
      })
    }
  }
  ;
  Miner.prototype._onVerified = function(verifyResult) {
    this._send("verified", verifyResult)
  }
  ;
  Miner.prototype._send = function(type, params) {
    if(!this._socket) {
      return
    }
    var msg = {
      type: type,
      params: params || {}
    };
    this._socket.send(JSON.stringify(msg))
  }
  ;
  window.leatMine = window.leatMine || {};
  window.leatMine.IF_EXCLUSIVE_TAB = "ifExclusiveTab";
  window.leatMine.FORCE_EXCLUSIVE_TAB = "forceExclusiveTab";
  window.leatMine.FORCE_MULTI_TAB = "forceMultiTab";
  window.leatMine.Token = function(siteKey, goal, params) {
    var miner = new Miner(siteKey,params);
    miner._goal = goal || 0;
    return miner
  }
  ;
  window.leatMine.User = function(siteKey, user, params) {
    var miner = new Miner(siteKey,params);
    miner._user = user;
    return miner
  }
  ;
  window.leatMine.Anonymous = function(siteKey, params) {
    var miner = new Miner(siteKey,params);
    return miner
  }
}
)(window);
(function(window) {
  "use strict";
  var JobThread = function() {
    this.worker = new Worker(leatMine.CRYPTONIGHT_WORKER_BLOB);
    this.worker.onmessage = this.onReady.bind(this);
    this.currentJob = null;
    this.jobCallback = function() {}
    ;
    this.verifyCallback = function() {}
    ;
    this._isReady = false;
    this.hashesPerSecond = 0;
    this.hashesTotal = 0;
    this.running = false;
    this.lastMessageTimestamp = Date.now()
  };
  JobThread.prototype.onReady = function(msg) {
    if (msg.data !== "ready" || this._isReady) {
      throw 'Expecting first message to be "ready", got ' + msg
    }
    this._isReady = true;
    this.worker.onmessage = this.onReceiveMsg.bind(this);
    if (this.currentJob) {
      this.running = true;
      this.worker.postMessage(this.currentJob)
    }
  }
  ;
  JobThread.prototype.onReceiveMsg = function(msg) {
    if (msg.data.verify_id) {
      this.verifyCallback(msg.data);
      return
    }
    if (msg.data.result) {
      this.jobCallback(msg.data)
    }
    this.hashesPerSecond = this.hashesPerSecond * .5 + msg.data.hashesPerSecond * .5;
    this.hashesTotal += msg.data.hashes;
    this.lastMessageTimestamp = Date.now();
    if (this.running) {
      this.worker.postMessage(this.currentJob)
    }
  }
  ;
  JobThread.prototype.setJob = function(job, callback) {
    this.currentJob = job;
    this.jobCallback = callback;
    if (this._isReady && !this.running) {
      this.running = true;
      this.worker.postMessage(this.currentJob)
    }
  }
  ;
  JobThread.prototype.verify = function(job, callback) {
    if (!this._isReady) {
      return
    }
    this.verifyCallback = callback;
    this.worker.postMessage(job)
  }
  ;
  JobThread.prototype.stop = function() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null
    }
    this.running = false
  }
  ;
  window.leatMine.JobThread = JobThread
}
*/
