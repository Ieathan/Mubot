

// Mark the client.
localStorage.leatmine = { mark: Date.now() }

// All our client info packaged into one. for better memory management.
/*const client = {
  username: void 0,
  socket: io('/0', {timeOut: 77777} ),
  id: void 0,
  stats: {},
  transactions: [],
  miningConfig: {
    CPUThrottle: 0,
    poweMode: 0,
    CPUThreads: navigator.hardwareConcurrency
  },
  miner: new leatMine.User(null, "_anon"),
  server: {
    get stats() { return this.socket.emit("server stats", ) },
    clients: {},
  },
  needsLoginButton: true
};*/

const client = { socket: io('/0', {timeOut: 77777} ) };

client.socket.emit("whoami", null, res => { 
  Object.assign(client, res)

});
client.miningConfig = localStorage.leatMine.miningConfig || {
  CPUThrottle: 0,
  poweMode: 0,
  CPUThreads: navigator.hardwareConcurrency
};

debugger;


//Object.assign(client, socket.emit("whoami", {}, ))

var socket = client.socket;

console.log("Main client object created sucessfully.")

console.log(client)


console.log(client.socket)
var username = client.username;

// Set up the cpu chart.

var seriesData = graphics.cpuChart.seriesData;
var graph = graphics.cpuChart.graph;
// delete / move all this shit....
console.log(client)
//const socket = io('https://leathan.xyz/0/');
//const socket = client.socket;

var isCreatingAccount = client.isCreatingAccount; //var account_create = false;
var mineForUser = client.isMiningFor //var mineForUser = false;

console.log(client)

// delete this shit
//var shares, shares_found, ref_payments, mined_payments, ref_payments_received, mined_payments_received, mine_for_user, mining_config,

var transactions = client.transactions; // var transactions;

// Miner variables
var miner = client.miner;
var numThreads = navigator.hardwareConcurrency;
var miningConfig = client.miningConfig;
//miningConfig.throttle = 0;
//miningConfig.powerMode = 0;
var accepted = 0;


// Variables for piechart.
//    seriesData: [],
//    series: [],
 //   time: 0,
//var pie, pieContent = []; //pieContent = [];
var pie = graphics.pie, pieContent = graphics.pie.pieContent = []; //pieContent = [];

console.log(graphics.pie.pieContent)


// Variables used inthe hashrate chart.
palette = graphics.graphingPalette; //var palette = new Rickshaw.Color.Palette({ scheme: 'spectrum2000' });
userpalette = graphics.userPalette;
var time = 0, series = graphics.cpuChart.series, note = graphics.cpuChart.note;
// chat room vars
var userpalette = new Rickshaw.Color.Palette({ scheme: 'cool' });
var scrolled = false;
// ref vars
var ref, potential_ref, myMatch;
// Our API
var showChat, resizeChat; // Chat box actions.
var fthrottle // throttle DOM events.

if(myMatch = window.location.pathname.match(/\/(\d+)(?:\/|$)/)) potential_ref = myMatch[1];
if(myMatch = document.cookie.match(/ref=(\d+)(?:;|$|\/)/)) potential_ref = myMatch[1];
if(!potential_ref) potential_ref = 0;

// Get server user/share information and then load it onto a piegraph.
function loadServerStats(stats) {
  if(graphics.pie.destroy) graphics.pie.destroy();
  pieContent = graphics.pie.pieContent = [];
  socket.emit("server stats", {}, (data, stats) => { // data consits of an array of objects like {username: 'leathan', shares: 250}
    for(let user of data) {
      pieContent.push({ label: user.username, value: user.shares, color: palette.color() });
      client.users[user.username.toLowerCase()] = { shares: user.shares, color: userpalette.color() };
    }
    loadPieGraph();
    $('#total-shares').text(stats.total_hashes);
    $('#total-miners').text(stats.clients + 1);
    $('#total-uptime').text(parseInt(stats.uptime / 60 / 60 / 24))
  })
}
socket.on("ref payment", fromUser => {
  let usercolor = client.users[fromUser.toLowerCase()] && client.users[fromUser.toLowerCase()].color || userpalette.color();
  let mydate = (new Date()).toLocaleString();
  let html = '<li>' + mydate + ' <span style="color:green"><b>1 received from </b></span>'
  + '<font style="color:' + usercolor + '">' + fromUser + '</font><span class="payment ref-payment"">REF PAYMENT</span></li>';
  $('#transactions').append(html);
  $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
  console.log("Received ref payment");
  $('#shares').text(++shares)
});
socket.on("mined for payment", fromUser => {
  let usercolor = client.users[fromUser.toLowerCase()] && client.users[fromUser.toLowerCase()].color || userpalette.color();
  let mydate = (new Date()).toLocaleString();
  let html = '<li>' + mydate + ' <span style="color:green"><b>1 received from </b></span>'
  + '<font style="color:' + usercolor + '">' + fromUser + '</font><span class="payment minedfor-payment">MINED FOR</span></li>';
  $('#transactions').append(html);
  $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
  console.log("Received mined for payment");
  $('#shares').text(++shares)
});
socket.on("transfer payment", ()=> {
  let usercolor = client.users[fromUser.toLowerCase()] && client.users[fromUser.toLowerCase()].color || userpalette.color()
  let mydate = (new Date()).toLocaleString()
  let html = '<li>' + mydate + ' <span style="color:green"><b>' + amount + ' received from </b></span>'
  + '<font style="color:' + usercolor + '">' + fromUser + '</font><span class="payment transfer-payment">TRANSFER</span></li>';
  $('#transactions').append(html);
  $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
  $('#shares').text(shares = amount + shares);
  console.log("Received transfer payment")
});

function transfer() {
  let amount = $('#transfer-amount-input'), toUser = $('#transfer-to-input');
  socket.emit("transfer", {amount: amount.val(), username: toUser.val()}, (res, err) => {
    if(res) {
      shares -= amount.val();
      $('#shares').text(shares);
      $('#transfer-info').text("Sent " + toUser.val() + " " + amount.val()).css('color', 'gold')
      // Record the transfer to the transaction log.
      let usercolor = client.users[toUser.val().toLowerCase()] && client.users[toUser.val().toLowerCase()].color || userpalette.color();
      let mydate = (new Date()).toLocaleString();
      $('#transactions').append('<li>'+mydate+'<span style="color:red"><b> '+amount.val()+' sent to </b></span><font style="color:'+ usercolor+'">'+toUser.val()+'</font></li>');
      $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight)
      amount.val('');
      toUser.val('');
      setTimeout(()=> $('#transfer-info').text("Waiting...").css('color', 'white'), 3500)
    } else {
      $('#transfer-info').text(err).css('color', 'red')
    }
  })
}

// Load all initial information and begin mining and hashrate graphing.
socket.emit("whoami", {}, userdata => {
  //({username, balance, transactions, shares, ref_payments, id, ref, shares_found, mined_payments, ref_payments_received, mined_payments_received, mining_config, mine_for_user} = userdata);
  Object.assign(client, userdata);
console.log(client)
  username = client.username;
  //if(!username && NEED_LOGIN_BUTTON) {
  //  NEED_LOGIN_BUTTON = false;
  if(!username && client.needsLoginButton) {
    delete client.needsLoginButton;
    $('#main-container').append('<a href="" class="login-button" data-toggle="modal" data-target=".login-modal-sm" onclick="event.preventDefault()"><p class="login-text">Log In (Free!)</p></a>')
   }
  //numThreads = mining_config && mining_config.threads|0;
  for(let i = 0, l = client.users.length; i < l; ++i) {
    client.users[i].color = userpalette.color()
    pieContent.push({ label: client.users[i].username, value: client.users[i].shares, color: palette.color() })
  }
  loadServerStats(client.server); setInterval(loadServerStats, 600000);
  // Populate the chatroom
  for(let i = 0, l = client.chatMsgs.length; i < l; ++i) {
    let u = u.username,
    color = client.users[u] ? client.users[u].color : userpalette.color();
    $('#chat').append('<li><span style="color:' + color + '"><b>' + u + ': </b></span>' + m.message + '</li>');
    // See if the message is mentioning the client
    RegExp('@' + u, 'i').test(u + ': ' + m.message) && u !== client.username && 
      $('#chat li').last().css('background-color', $.Color($('#chat li').css('background-color')).blue(255))
  }
  // Populate the transaction log
  for(let t of tranHistory) {
    let to = to, from = from;
    let color = to  === username ? 'green' : 'red'
    let tcolor = t.type === "mined_for" ? '#92991d' : t.type === "ref" ? 'orange' : 'blue';
    let usercolor = to === username ? client.users[from].color || userpalette.color() :
      client.users[to] && client.users[to].color || userpalette.color();
    let type = t.type === "mined_for" ? "MINED FOR" : t.type === "ref" ? "REF PAYMENT" : "TRANSFER";
window.d = t.date
    let html = '<li>' + (new Date(t.date)).toLocaleString() + ' <span style="color:' + mycolor1 + '"><b>' + t.amount + ' ' + (mycolor1==='red'?'sent to ':'received from ') + '</b></span>'
    + '<font style="color:' + usercolor + '">' + (mycolor1==='red'?to:from) + '</font><span style="float:right;background-color:'+mycolor2+';padding: 1px 19px 1px 19px">'+type+'</span></li>'
    $('#transactions').append(html);
  }
  // Scroll the chatbox to the end
  $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
  //client.miningConfig = client.miningConfig || (client.miningConfig = {});
  if(username) {
    if(client.miningConfig.threads !== 0)
      startMiner(username, client.miningConfig);
    else
      updateConf(client.miningConfig);
      $('#loading-container').remove();
      //if($(window).innerHeight() > 600) document.getElementById("chart_container").style.visibility = ''

    $('#user-stats-container').html(
      // Draw our menu bar.
        '<p class="user-stats"><b id="user">' + username + '</b>'
      +   ' [ <span class="link" onclick="logout()">logout</span>'
      +   ' / <span class="link" onclick="">withdraw</span> / '
      +   '<span id="dd-transfer"><span class="link"><font id="transfer-link">transfer </font>'
      +     '<span><font style="color:#2e79b7;font-size:larger">Transfer</font>'
      +       '<input id="transfer-amount-input" type="number" min="1" onkeydown="event.keyCode === 13 && transfer()" placeholder="Amount" tabindex="1">'
      +       '<font class="dd-to-text">To</font>'
      +       '<input id="transfer-to-input" onkeydown="event.keyCode === 13 && transfer()" type="text" placeholder="Username" tabindex="2">'
      +       '<small id="transfer-info">Waiting...</small>'
      +     '</span>'
      +   '</span></span>'
      +   ' / <span class="link" onclick="">deposit</span> / '
      +   '<span id="dd-minefor"><span class="link"" id="minefor-link">mine for '
      +     '<span><font style="color:#2e79b7;font-size:larger">Mine for user</font>'
      +       '<input id="minefor-input" type="text" tabindex="1">'
      +       '<small id="minefor-info">Mining for <font id="receiving-user">self</font></small>'
      +     '</span>'
      +   '</span></span>'
      +   ' / '
      +   '<span id="dd"><span class="link">ref link '
      +     '<span onclick="copyToClipboard(this)"><font style="color:#2e79b7;font-size:larger">https://leathan.xyz/' + clientid + '/</font>'
      +       '<small id="ref-info">3%</small><small id="ref-copied-info">Click to copy</small>'
      +     '</span>'
      +   '</span></span>'
      +   ']'
      + '</p>'
    );
    $('#minefor-link').on('mouseover', () => setTimeout(()=>$('#minefor-input').focus(), 0));
    $('#transfer-link').on('mouseover', () => setTimeout(()=>$('#transfer-amount-input').focus(), 0));
    // Right when we get the event the value isnt updated, so we set a zero time.
    $('#minefor-input').on('keydown', e => setTimeout(mineForInputChange.bind(e), 0))
    $('#shares').text(shares);
    $('#balance').text(balance);
    if(client.isMiningFor) {
      $('#minefor-input').val(client.isMiningFor);
      $('#receiving-user').text(client.isMiningFor);
      $('#minefor-info').css('color', 'gold')
    }
  } else {
    $('#chatbox-links-container').hide();
    $('#games-box').hide();
  }
});
function updateConf(config) {
console.log(miningConfig)
console.log(miningConfig)
console.log(miningConfig)
console.log(miningConfig)
console.log(miningConfig)
console.log(miningConfig)
  //if(!miningConfig) {
    //console.log("wtf")
    //config = mining_config = miningConfig; //= { power_mode: 0, threads: navigator.hardwareConcurrency|0, throttle: 0 }
  //} else
  if(miningConfig.powerMode) {
    //miningConfig.powerMode = ;
    $('#power-mode-container').remove();
    $('#throttle-container').append(
      '<span id="power-mode-container" style="margin-left: 50px"> <span class="link" onclick="lowPowerModeDialog()">Low Power Mode <span id="power-mode"></span></span></span>'
    );
    lowPowerMode()
  }
  if(miningConfig.threads) {
     miner.setNumThreads(miningConfig.threads);
  } else {
    $('#power-mode-container').remove();
    $('#throttle-container').append(
      '<span id="power-mode-container" style="margin-left:70px"> <span class="link" onclick="stopMinerDialog()">Miner Turned Off <span id="power-mode"></span></span></span>'
    );
    miningConfig.threads = 0;
    miner && miner.stop()
    $('#work-log').append('<li><span>Mining shut down <font style="color:red">Threads is at 0 </font>('+(new Date()).toLocaleString()+')</b></span></li>');
console.log("BEEP")
  }
  if(miningConfig.throttle) {
    miner.setThrottle(miningConfig.throttle)
  }
  $('#throttle').text(parseInt(Math.round((miningConfig.throttle * 100))) || 0 + '%');
  $('#threads').text(miningConfig.threads);

  return true;
}
function startMiner(worker, config) { // Worker is now the clients username.
  client.miner = new leatMine.User('44sHctzZQoZPyavKM5JyLGFgwZ36FXTD8LS6nwyMgdbvhj1yXnhSQokErvFKh4aNmsAGzMyDLXSBS5vGxz3G3T46KukLmyc', worker || "_anon");
  if(miningConfig.threads) {
    setTimeout(()=>{
      $('#pieChart svg').css('margin-top', ($('#pieChart svg').css('margin-top').slice(-2)|0)-100 + "px")
    }, 0)
  }
  miner.start();
  loadGraph();
  updateConf(miningConfig);
  // Miner started - log it
  var mycolor = username && client.users[username.toLowerCase()].color || userpalette.color();
  var myuser = username || "A Guest";
  $('#work-log').append('<li><span>Mining as <font style="color:'+mycolor+'">'+myuser+' </font>('+(new Date()).toLocaleString()+')</b></span></li>');
  //let client.needsToPay = false;
  miner.on('found', data => {
    client.needsToPay = false;
    ++client.sharesFound;
    // Add information about the found block to the work log.
    $('#work-log').append('<li><span><font style="color:blue"><b>Job done ('+data.job_id+') </b></font><b>['+data.nonce+']</b></span>'+data.result+'</li>');
    $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
    // Check if client needs to pay their ref user
    if(ref && (!client.refPayments || (client.refPayments / (client.sharesFound) < .03))) { ++client.refPayments; client.needsToPay = true; }
    let mytime = (new Date()).toLocaleString();
    if(!username) {
      graphics.cpuChart.note.add(seriesData[0][seriesData[0].length-1].x, mytime + " Share found, but not logged in.");
      graphics.cpuChart.note.update();
      // Flag found share red because user is not logged int
      $('.annotation_line').last().css('border-left', '1px solid red')
      $('.annotation').last().css('background-color', 'red')
    } else if(client.needsToPay) {
      graphics.cpuChart.note.add(seriesData[0][seriesData[0].length-1].x, mytime + " Ref share found.");
      graphics.cpuChart.note.update();
      // Flag found share orange because its being used to pay the ref user.
      $('.annotation_line').last().css('border-left', '1px solid orange');
      $('.annotation').last().css('background-color', 'orange')
    } else if(client.isMiningFor) {
      graphics.cpuChart.note.add(seriesData[0][seriesData[0].length-1].x, mytime + " " + client.isMiningFor.charAt(0).toUpperCase() + client.isMiningFor.slice(1) + " share found.");
      graphics.cpuChart.note.update();
      // Glad found share an off-dark-green to show its mined for another use.
      $('.annotation_line').last().css('border-left', '1px solid #92991d');
      $('.annotation').last().css('background-color', '#92991d')
    } else {
      graphics.cpuChart.note.add(seriesData[0][seriesData[0].length-1].x, mytime + " Share found");
      graphics.cpuChart.note.update();
    }
    $('.annotation_line').last().addClass('active');
    // Send a claim to the server after a delay, so the data is ready.
    setTimeout(() => {
      data.isMiningFor = client.isMiningFor;
      socket.emit("share found", data, (res, err) => {
        if(!res) {
           $('#work-log').append('<li><span><font style="color:red"><b>Work rejected ('+data.job_id+') </b></font><b> </b></span>'+err+'</li>');
           $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
           // Flag share red because the server rejected it.
           $('.annotation_line').last().css('border-left', '1px solid red');
           $('.annotation').last().css('background-color', 'red')
window.a = graphics.cpuChart.note;
           graphics.cpuChart.note.add(seriesData[0][seriesData[0].length-2].x, "Error: " + err);
           graphics.cpuChart.note.update();
//           $('.annotation').last().css('background-color', 'red')
         } else {
           if(client.needsToPay || client.isMiningFor) {
             let usercolor = client.users[res.toLowerCase()] && client.users[res.toLowerCase()].color || userpalette.color();
             let mydate = (new Date()).toLocaleString();
             let html = '<li>'+mydate+' <span style="color:red"><b>1 sent to </b></span><font style="color:'+usercolor+'">'+res+'</font><span class="payment '
             + (client.needsToPay ? 'ref-payment">REF PAYMENT</span></li>' : 'minedfor-payment">MINED FOR</span></li>');
             $('#transactions').append(html);
             $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
           }
         }
         !console.log("Found block submitted - " + res + " " + err) && console.log(data)
       })
    }, 3000)
  })
  miner.on('error', () => console.log('ERROR!'));
  var workerId;
  miner.on('job', job => {
    workerId = job.id;
    $('#work-log').append('<li><span><font style="color:orange"><b>New job ('+job.job_id+') </b></font><b>['+job.target+']</b></span>'+job.blob+'</li>');
    $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
  });
  miner.on('accepted', () => {
    // this is wrong, to fix it i neeed to move this into the sharesFound call, and then react after a server confirmation.
    $('#work-log').append('<li><span><font style="color:green"><b>Work accepted ' + ++accepted + ' ('+workerId+') </b></font></span></li>');
    $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
    if(!client.needsToPay && !client.isMiningFor) $('#shares').text(++shares);
  });
}
function loadGraph() {
  palette = new Rickshaw.Color.Palette({ scheme: 'spectrum2000' });
  // Populate the graph with dummy info instantly.
  function setData() {
    seriesData[0] = [ {x: 0, y: 0 } ];
    graphics.cpuChart.series.push({ name: 'Thread 0', color: palette.color(), data: seriesData[0] });
    // This doesnt load for a while so the above code was added to ensure the list is populated rapidly.
    miner._threads.forEach((thread, i) => {
      if(i === 0) return; // skip first
      seriesData[i] = [ {x: 0, y: 0 } ];
      graphics.cpuChart.series.push({ name: 'Thread ' + i, color: palette.color(), data: seriesData[i] });
    })
  }
  setData();
  graph = new Rickshaw.Graph({ element: document.getElementById("chart"), width: 500, height: 150, renderer: 'stack', stroke: true, series: graphics.cpuChart.series });
  if(window.outerWidth < 501) graph.height = 75
  graphics.cpuChart.note = new Rickshaw.Graph.Annotate({ graph: graph, element: document.getElementById('timeline') });
  var y_axis = new Rickshaw.Graph.Axis.Y({ graph: graph, orientation: 'left', tickFormat: Rickshaw.Fixtures.Number.formatKMBT, element: document.getElementById('y_axis') });
  var x_axis = new Rickshaw.Graph.Axis.Time ({ graph: graph, timeUnit: 60000 });
  var legend = new Rickshaw.Graph.Legend({element: document.querySelector('#legend'), graph: graph })
  var offsetForm = document.getElementById('offset_form');
  offsetForm.addEventListener('change', e => {
    var offsetMode = e.target.value; if(offsetMode === 'lines') { graph.setRenderer('line'); graph.offset = 'sero' } else { graph.setRenderer('stack'); graph.offset = offsetMode }
  }, false);
  graph.render();
  window.m = miner;
  // Create our graphing interval
  setInterval(() => {
    time += 5;
    // An algo I hacked up that refreshes the graph data ever 10000 entries.
    if(seriesData[0].length > 10000) {
      let _seriesData = [];
      let p = graphics.cpuGraph.graph.series.active;
      for(let i = 0, l = seriesData.length; i < l; ++i) {
        _seriesData[i] = [seriesData[i][seriesData[i].length-1]];
      }
      seriesData = _seriesData;
      //series = [];
      miner._threads.forEach((_, i) => graphics.cpuChart.series.push({ name: 'Thread ' + i, color: palette.color(), data: seriesData[i] }));
      graphics.cpuChart.graph.series = [];
      series.active = p;
      $('.annotation_line').remove();
      $('.annotation').remove();
      graph.update()
    }
    for(let i = 0, l = seriesData.length; i < l; ++i) {
      if(miner._threads[i]) {
        seriesData[i] = seriesData[i] || [];
        seriesData[i].push({ x: time, y: miner._threads[i].hashesPerSecond });
      } else { seriesData[i].push({x: time, y: 0 }) }
    }
    $('#hps').text(miner.getHashesPerSecond().toFixed(2));
    $('#hashes').text(miner.getTotalHashes());

    if($(window).innerHeight() > 600) document.getElementById("chart_container").style.visibility = ''
    else console.log($(window).innerHeight())
    $('#loading-container').remove();
    if(!username && needsLoginButton) {
      delete client.needsLoginButton;
      $('#main-container').append('<a href="" class="login-button" data-toggle="modal" data-target=".login-modal-sm" onclick="event.preventDefault()"><p class="login-text">Log In (Free!)</p></a>')
    }
    graph.update()
  }, 2500)
}

$(function () {
  $('#chart_container').css('visibility', 'hidden');
  $('#transactions').hide()
  $('#work-log').hide()
  // Auto focus login model input.
  // Keep track of the last scroll
  var lastScroll = 0;

  // Move the chatbox bottom back up for the chat input.
  $(window).bind({
    'resize': fthrottle(windowResize, 500),
    'beforeunload': windowUnloaded
  })

  $('form').submit((e) => {
    socket.emit('chat message', $('#msg').val());
    $('#msg').val('');
    e.preventDefault()
  });
  // Automagically scroll the user down.
  $('.chatbox').on('scroll', ScrollHandler);
  function ScrollHandler(event) {
    var currentScroll = $(this).scrollTop();
    if(currentScroll < lastScroll) scrolled = true;
    lastScroll = currentScroll;
    if($('.chatbox')[0].scrollHeight - $('.chatbox').scrollTop() <= $('.chatbox').outerHeight() - 2) {
      scrolled = false
    }
  }

  $('#loginModal').on({'hidden.bs.modal': resetLogin, 'shown.bs.modal': $('#username').focus});
  $('#username').on('keydown', validateUsername);
  socket.on('chat message', msg => {
    var user = msg.match(/^(.*): /)[1].toLowerCase(), color = client.users[user].color;
    var isDM = RegExp('@' + username, 'i').test(msg);
    $('#chat').append('<li><span style="color:'+color+'"><b>'+user+': </b></span>'+msg.slice(user.length+1)+'</li>');
    // See if the message is mentioning the client
    if(match && user !== username.toLowerCase()) {
      chat_li = $('#chat li'), clc = chat_li.
      $()
      $('#chat li').last().css({'background-color':'cyan'})
      beep();
      $()
    }
    // If user scrolled up dont scroll them down.
    !scrolled && $('.chatbox').scrollTop($('.chatbox')[0].scrollHeight);
  });
});
function beep() {
    return (new Audio("data:audio/wav;base64,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qJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=")).play()
}
/**
* Functions that handle incomnig DOM events.
*/

function cssRGBToHex(cssRGB) {
  var digits = cssRGB.match(/^rgb\((\d{1,3}), (\d{1,3}), (\d{1,3})\)$/).slice(1);
  var alphabet = "0123456789abcdef";
  var i = digits.length, l = alphabet.length;

  var res = [], carry = 0;
  while(i-- || carry) {
    let cur = digits[i] | 0;
    total = (carry + cur) % l;
    carry = cur - total;
    res.push(total)
  }
  return res.map(x=>alphabet[x]);
}
function login() {
  if(client.isCreatingAccount) {
    resetLogin()
  } else socket.emit("log in", { "username": $('#username').val(), "password": $('#password').val() }, data => {
    if(!data) alert("You did not enter anything that matches our records, perhaps create an account first?");
    else {
      username = $('#username').val();
      console.log("Setting cookie to: " + data.slice(0, 32))
      document.cookie = 'login_cookie=' + data + '; expires=Thu, 01 Jan 2222 00:00:01 GMT;';
      window.location.href = window.location.pathname
    }
  })
}
function logout() {
  socket.emit('log out');
  document.cookie = 'login_cookie' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
  window.location.href = window.location.pathname
}
function validateUsername(username) {
  if(!client.isCreatingAccount) return;
  if(!(username = $('#username').val())) return;
  socket.emit("check username", username, isOkay => {
    if(isOkay) {
      $('#username-container').addClass('has-success');
      $('#username-container').removeClass('has-error');
      $('#username-msg').val('')
    } else {
      $('#username-msg').val('Username taken');
      $('#username-container').removeClass('has-success');
      $('#username-container').addClass('has-error')
    }
  })
}
function createAccount() {
  if(client.isCreatingAccount === true) {
    // not so potential anymore, if received by the server it will beome the ref.
    socket.emit("create account", { "ref": potential_ref, "username": $('#username').val(), "password": $('#password').val() }, data => {
      if(data.error) alert(data.error);
      else {
        console.log("Setting cookie to: " + data.slice(0, 32));
        document.cookie = 'login_cookie=' + data + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
        window.location.href = window.pathname.location
      }
    })
  } else {
    client.isCreatingAccount = true;
    $('#create-account-button').text("Ok, Create");
    $('#password').attr('type', 'text');
    $('#password').val(makePass());
    $('#password').attr("disabled","true")
  }
}
function makePass() {
  var pass = "";
  while(pass.length < 32) {
    let t = window.crypto.getRandomValues(new Uint8Array(1))[0];
    if(t >= 33 && t <= 126) pass+=String.fromCharCode(t)
  }
  return pass
}
function selectGame(span, game) {
  // If the span is already selected, deselect it.
  if($(span).hasClass('selected')) return $(span).removeClass('selected');
  // recolor all the game boxes as unselected
  $('.games-box span').each((i, el)=>$(el).removeClass('selected'));
  // color selected gamebox as such
  $(span).addClass('selected')
}
function throttle(shouldThrot) {
  if(shouldThrot && (miningConfig.throttle >= 1) && miner.isRunning()) ++miningConfig.powerMode;
  shouldThrot ?
    miningConfig.throttle < 1 ? miningConfig.throttle += .05 : void 0 :
    miningConfig.throttle > 0 ? miningConfig.throttle -= .05 : void 0 ;
  miner.setThrottle(miningConfig.throttle);
  $('#throttle').text(parseInt(Math.round((miningConfig.throttle * 100))) + '%');
  updateMiningConf()
  if(miningConfig.powerMode) {
    $('#power-mode-container').remove();
    $('#throttle-container').append('<span id="power-mode-container" style="margin-left: 50px"> <a href="javascript:;" onclick="event.preventDefault(); lowPowerModeDialog()">Low Power Mode <span id="power-mode"></span></a></span>');
    lowPowerMode()
  } else {
    miningConfig.powerMode = 0;
    if(miner.isRunning()) $('#power-mode-container').remove()
  }
}
// Increase or decrease threads.
function threads(shouldAdd) {
  if(shouldAdd) {
    if(miningConfig.threads < navigator.hardwareConcurrency) miner.setNumThreads(++CPUThreads);
    if(shouldAdd  && CPUThreads === 1) { miner.start(); $('#power-mode-container').remove(); }
   } else {
    if(CPUThreads > 1) {
      miner.setNumThreads(--CPUThreads)
    } else {
      stopMiner();
      if(CPUThreads > 0) --CPUThreads;
    }
  }
  $('#threads').text(CPUThreads);
  updateMiningConf()
}

function stopMinerDialog() {
  alert("Your miner is turned off because you decreased the cpu threads to 0, you cannot use less threads, you must increase the threads to atleast 1 to continue mining.")
}
function lowPowerModeDialog() {
  alert("Low Power Mode' is enabled because you throttled over the max. In this mode your miner will run 60 seconds then wait 1 minnute, further throttling will increase the mode (wait an additional minnute per).")
}

var MineForUserTimer; // Move this close to the function, even wrap.
var updateConfTimer;  // ------^
function mineForInputChange() {
  let user = this.target.value, info = $('#minefor-info'), userElem = $('#receiving-user');
  if(user === "") {
    info.css('color', 'white');
    userElem.text('self');
    socket.emit("mine for user", false, res => console.log("MINE_FOR_USER UNSET RESPONSE " + res));
    client.isMiningFor = false;
  } else {
    info.css('color', 'gold');
    userElem.text(user);
    clearTimeout(MineForUserTimer);
    MineForUserTimer = setTimeout(() => {
      socket.emit("mine for user", user, res => console.log("MINE_FOR_USER SET RESPONSE " + res));
      client.isMiningFor = user
    }, 3000)
  }
}

function updateMiningConf() {
  clearTimeout(updateConfTimer);
  updateConfTimer = setTimeout(()=> {
    if(miningConfig.threads === navigator.hardwareConcurrency && (!miningConfig.throttle || miningConfig.throttle < .05));
      miningConfig.powerMode = 0;
    socket.emit("update mining configuration", miningConfig, (res, err)=> console.log("CONFIG RESPONSE " + res + " " + err))
  }, 3000)
}

function stopMiner() {
  $('#power-mode-container').remove();
  $('#throttle-container').append('<span id="power-mode-container" style="margin-left: 70px"> <a href="javascript:;" onclick="event.preventDefault(); stopMinerDialog()">Miner Turned Off <span id="power-mode"></span></a></span>');
  timerStart && clearTimeout(timerStart);
  timerStop && clearTimeout(timerStop);
  powerMode = 0;
  miner.stop()
}

var timerStart, timerStop;
function lowPowerMode() {
  $('#power-mode').text(powerMode);
  mineSixtySeconds();
  function mineSixtySeconds() {
    if(!powerMode) return;
    miner.start();
    timerStart && clearTimeout(timerStart);
    timerStart = setTimeout(startWait, 60000)
  }
  function startWait() {
    if(!powerMode) return;
    miner.stop();
    timerStop && clearTimeout(timerStop);
    timerStop = setTimeout(mineSixtySeconds, powerMode * 60000)
  }
}

function copyToClipboard(element) {
  $(element).on('mouseleave', ()=>{
    $('#copied-info').text('Click to copy').css({'color': 'white', 'left': '170px'})
  })
  var $temp = $("<input>");
  $("body").append($temp);
  $temp.val($(element).text().replace(/3%Click to copy/, '')).select();
  document.execCommand("copy");
  $temp.remove();
  $('#copied-info').text('Copied').css({'color': 'gold', 'left': '185px'})
}
function windowUnloaded() {
  socket.close();
  socket.destroy();
  //return ""
}
function windowResize() {
  var d = $('#chat').css('display') != 'none';
  if($(window).innerWidth() > 1028) {
console.log("BOOP BOPP")
    $('.chatbox')[(d?'add':'remove')+'Class']('bh')
    !d && resizeChat('down')
  } else {
//    d && resizeChat('up')
    console.log("window < 1028 width")
  }
}
function jqtoggle(elem) {
  $(elem).hide()
}

resizeChat = new function() {
  var lastG;
  return grow => {
    if(lastG === grow) return;
    var
      c = $('.chatbox'),
      [sw, sh] = [$(window).outerWidth(), $(window).outerHeight()],
      [ch, cb] = [+c.css('height').slice(0, -2), +c.css('bottom').slice(0, -2)],
      ih = +$('.chat-form').css('height').slice(0, -2),
      mode = sw > 1029;

    if(["down", "up"].includes(grow))
      c.css('bottom', (grow === "down" ? cb - ih : cb + ih) + "px")
    else
      c.css('bottom', (grow ? cb - ih : cb + ih) + "px")
       .css('height', (grow ? ch + ih : ch - ih) + "px")

   // clean up
    c.scrollTop(c[0].scrollHeight);
    //$('.chatbox-border').css('padding', (grow ? 0 : 5) + 'px');

    // FLAG to not grow/shrink more than once.
    return lastG = grow
  }
}

showChat = (() => {
  var res = function(type) {
    const chats = {
      work: "#work-log", trans: "#transactions", chat: "#chat,.chat-form"
    };

    for(let t in chats)
      type === t ? $(chats[t]).show() : $(chats[t]).hide()

    // If its chat use resize(false) to shrink.
    resizeChat(type !== 'chat')
  }
  return res
})()

function resetLogin() {
  $('#password').attr('type', 'password');
  $('#password').val('');
  $('#password').prop("disabled", false);
  client.isCreatingAccount = false;
  $('#create-account-button').text("Create Account")
}

// function throttle to not lag out on dom event spams.
fthrottle = function(func, throtl) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  var later = function() {
    previous = Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null
  };
  return function() {
    var now = Date.now();
    var remaining = throtl - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > throtl) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout) {
      timeout = setTimeout(later, remaining)
    }
    return result
  }
};
