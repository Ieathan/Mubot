angular.module('myApp', ['angularMoment'])
.config(($locationProvider) => {
  $locationProvider.html5Mode({ enabled: true, requireBase: false })
})
.controller('mainController', ($scope, $http, $location, $rootScope, $timeout, $window, socket) => {
  //const socket = io('/bitmark');
  $scope.state = document.cookie.substr(document.cookie.indexOf("state")+6, document.cookie.indexOf(";")-6);
  $scope.data = {}; $rootScope.message_needed = {}; $scope.replyto = "";
  $scope.loaded = {}; $rootScope.message = ""; $rootScope.marking_msg = "";
  $scope.usersOnline = {}; $scope.amountOnline = 0; $scope.private_messages = [];

  // Every time the script is requested load the information
  $http.get("/bitmark/api/posts").then((res) => { $scope.posts = res.data });
  $http.get("/bitmark/api/info").then((res) => {
    $scope.data = res.data;
    var amount = 0;
    for(i = 0, l = $scope.data.notifications.length; i < l; i++) {
     amount += $scope.data.notifications[i].amount;
    }
    $scope.notificationAmount = amount
  });
  // And get new info via socket.io
  socket.on("new post", post => {
    $scope.posts.push(post)
  });
  // New user notification.
  socket.on("new data", data => {
    $scope.data = data;
    $scope.notificationAmount++
  });
  socket.on("user logged in", user => {
    $scope.usersOnline[user.username] = user;
    $scope.amountOnline++
  });
  socket.on("user logged out", user => {
    delete $scope.usersOnline[user.username];
    $scope.amountOnline--
  });
  // Emitted once on connection.
  socket.on("users online", usersOnline => {
    $scope.usersOnline = usersOnline
    $scope.amountOnline = Object.keys(usersOnline).length;
  });

  $scope.notificationClicked = notification => {
    $scope.notificationAmount -= notification.amount;
    $scope.select({'_id' : notification.id });
    $http.get("/bitmark/api/delete_notification/" + notification.id).then(()=>{})
  };
  $scope.reasonBlur = post => {
    $scope.cancel = false;
    $scope.isDisabled = true;
    $timeout(() => {
      $scope.isDisabled = false;
      if (!$scope.cancel) {
        $rootScope.message_needed[post._id] = false;
        $scope.mark(post)
      }
    }, 200)
  };
  const PM_WIDTH = 300;
  var   PM_RIGHT = 0;
  $scope.privateMessage = user => {
    var len;
    if(len = $scope.private_messages.length) {
      for(let i = 0; i < len; i++) {
        if(user === $scope.private_messages[i].user) {
          // The window exists, so in the future come back
          // here and minimize/maximize the window.
          return;
        }
      }
    }
    // 170 is the user-list width. len * 10 is spacing.
    if((len+1) * PM_WIDTH + (len * 10) + 170 > $window.innerWidth) {
      return alert("To many windows!")
    }
    PM_RIGHT = 180 + (PM_WIDTH * len) + 10 * len;
    var pm = {};
    pm.user = user;
    pm.style = { 'background-color': '#ffffff',  'border': '1px solid #b0b0b0', 'bottom': '0', 'display': 'none',
      'height': '348px', 'position': 'fixed', 'right': PM_RIGHT + 'px', 'width': '300px', 'font-family': "'Open Sans', sans-serif"
    }
    $scope.private_messages.push(pm)
window.pms = $scope.private_messages;
  };
  $scope.mark = post => {
    $rootScope.message_needed[post._id] = false;
    post.marking_msg = $rootScope.marking_msg; $rootScope.marking_msg = "";
    $scope.data.username === post.username || $http.post("/bitmark/api/mark/", post).then(()=>{ $scope.data.balance-- });
  };
  $scope.updateState = (path, state, scroll) => {
    scroll = scroll || 0
    var cookie_state = state;
    if (state == 'home') {
      if ($scope.replyto.length === 24) cookie_state = $scope.replyto;
    }
    $location.old = $location.state({scrollto: scroll});
    $location.new = {
      selected_style: ($scope.replyto.length==24?{ 'width': '650px' }:''),
      replyto: $scope.replyto,
      state: cookie_state,
      scrollto: scroll
    };
    try { if ($location.new.state === $location.old.state) return; } catch(e) {} //Error is thrown first time page is loaded since $location.old is undefined.
    state === 'home' && (state = '');
    $location.state($location.new).path(path + state);
  };
  $scope.updateState("/bitmark/", "home");
  $scope.select = post => {
    if($scope.replyto === post._id) return;
    $scope.selected_style = {"width": "650px"};
    $scope.replyto = post._id;
    document.cookie = 'state=' + post._id + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    $scope.state = post._id;
    post.scrollto = document.documentElement.scrollTop || document.body.scrollTop
    $scope.updateState('/bitmark/post/', post._id, post.scrollto);
  };
  if ($scope.state.length === 24) $scope.select({'_id': $scope.state});
  // Watch for location changes so we can apply state accordingly
  $scope.$on('$locationChangeSuccess', (_, __, ___, ____, oldstate) => {
    var state_data = $location.state()
    if (!state_data) return
    $scope.selected_style = state_data.selected_style;
    $scope.replyto = state_data.replyto;
    $scope.state = state_data.state;
    document.cookie = 'state=' + state_data.state + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
    if(!oldstate) oldstate = {}
    setTimeout(() => {
      window.scrollTo(0, (oldstate.scrollto || 0));
    }, 0)
  });
  $scope.postGlow = post => {
    return {  "box-shadow" : "0 0 " + post.marks / 2 + "px purple" };
  };
  $scope.mergeStyles = styles => {
    var obj = {};
    for(let i = 0, l = styles.length; i < l; i++) {
      for(let key in styles[i]) obj[key] = styles[i][key];
    }
    return obj;
  };
  $scope.back = post => {
    document.cookie = 'state=' + post.replyto + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    if (post.replyto) {
      $scope.state = post.replyto;
      $scope.replyto = post.replyto;
      $scope.updateState('/bitmark/post/', post.replyto)
    } else {
      $scope.selected_style = "";
      $scope.replyto = "";
      $scope.updateState('/bitmark/', 'home');
    }
  };
  $scope.create = $event => {
    $http.post("/bitmark/api/create", { 'message': $rootScope.message, 'replyto': $scope.replyto }).then(res => {
      $rootScope.message = "";
      $event.target.blur();
      $event.target.rows = 1;
    }).catch(err => alert("Technical difficulties, just try again " + err))
  };
  $scope.cancelMarking = post => {
    $rootScope.message_needed[post._id] = false;
    $rootScope.marking_msg = '';
    $scope.cancel = true;
  };
  $scope.logout = () => {
    document.cookie = 'login-cookie' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    document.cookie = 'state' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    window.location.href = "/bitmark";
  };
})
.filter('reverse', () => {
  return items => {
    if (items) return items.slice().reverse();
  }
})
.directive('autoFocus', () => {
  return {
    link: {
      post: (scope, element) => { element[0].focus() }
    }
  }
})
.directive('loaded', () => {
   var navBarLoaded = false;
   return {
     restrict: 'A',
     link: (scope, elem, attr) => {
       scope.$watch(() => {
         try { return document.getElementById(attr.loaded).scrollHeight } catch(e) { return }
       }, (newVal, oldVal) => {
         if (!newVal) return;
         if(newVal - oldVal == 42) return; // Hack to fix bug: (textarea is sending 2 scrollheight updates when its drawn)
         if (attr.loaded == "navbar" && navBarLoaded) return;
         if (!navBarLoaded) navBarLoaded = true;
         elem[0].style.paddingTop = newVal + 10 + 'px';
       });
     }
   }
})
.factory('socket', function ($rootScope) {
  const socket = io('/bitmark');
  return {
    on: function (eventName, callback) {
      socket.on(eventName, function () {
        const args = arguments;
        $rootScope.$apply(function () {
          callback.apply(socket, args);
        });
      });
    },
    emit: function (eventName, data, callback) {
      socket.emit(eventName, data, function () {
        const args = arguments;
        $rootScope.$apply(function () {
          if (callback) {
            callback.apply(socket, args);
          }
        });
      })
    }
  };
})

