// Four dependencies.
angular.module('myApp', ['angularMoment', 'monospaced.elastic', 'ngDisableScroll'])
.config(['$locationProvider', '$compileProvider', ($locationProvider, $compileProvider) => {
  // optimizations.
  $compileProvider.commentDirectivesEnabled(false);
  $compileProvider.cssClassDirectivesEnabled(false);
  $compileProvider.debugInfoEnabled(false);
  // ensure html5 is required
  $locationProvider.html5Mode({ enabled: true, requireBase: false })
}])
// Here we explicitly require injections (array format) such that during minitifcation the implicit calls are not needed.
.controller('mainController', ['$scope', '$http', '$location', '$timeout', '$window', 'socket', ($scope, $http, $location, $timeout, $window, socket) => {
  // VARIABLE DECLARATIONS.
  const TYPING_TIMER = {}; // Keep track of whoes typing.
  $scope.state = document.cookie.substr(document.cookie.indexOf('state')+6, document.cookie.indexOf(';')-6);
  $scope.loaded = {}; $scope.usersOnline = {}; $scope.data = {}; $scope.replies = {}; $scope.posts = {};
  // Every time the script is requested load the posts, and user information
  $http.get('/bitmark/api/posts').then(res => {
    for(let i = 0, l = res.data.length; i < l; ++i) {
      let post = res.data[i];
      $scope.posts[res.data[i]._id] = post;
      $scope.replies[post.replyto] ? $scope.replies[post.replyto].push(post) : $scope.replies[post.replyto] = [post];
    }
window.s = $scope;
  });
  $http.get('/bitmark/api/info').then(res => {
    $scope.pms = res.data.pms || [];
    delete res.data.pms;
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      // I merge in exists: true here so that the backend knows this window isn't
      // being opened. Its just being loaded, minimized windows are requested too.
      socket.emit('private message open', Object.assign($scope.pms[i], {exists: true}))
    }
    // Dont need do do this, but makes things cleaner.
    delete res.data._id; delete res.data.__v;
    // I merge in awaiting_pm: {} because mongoose returns nothing upon empty obj.
    Object.assign($scope.data, {awaiting_pm:{}}, res.data);
    // Define an amount propery on our notifications array, it loops through all the notifications adding up their amount feild. returning the total.
    Object.defineProperty($scope.data.notifications, 'amount', { get: function(){ var n=0; for(let i=0, l=this.length; i<l; ++i) n+=this[i].amount; return n } });
    // Here we use _amount so as to not collide with a potential user named amount. (_ at the start of names is disallowed).
    Object.defineProperty($scope.data.awaiting_pm, '_amount', { get: function(){ var n=0; for(let i=0, k=Object.keys(this), l=k.length; i<l; ++i) n+=this[k[i]]; return n } });
    $scope.data.awaiting_pm._amount && alert('You have ' + $scope.data.awaiting_pm._amount + ' pm(s) awaiting you. \n\nThis message will be replaced by the UI Soon =).')
  });
  // If the script has been disconnected for multiple attempts reload the script to ensure no data loss.
  socket.on('reconnect', attempts => attempts > 1 && (window.location.href = '/bitmark'));
  // Request the users online.
  socket.emit('users online');
  socket.on('new post', post => {
    $scope.posts[post._id] = post;
    $scope.replies[post.replyto] ? $scope.replies[post.replyto].unshift(post) : $scope.replies[post.replyto] = [post];
    if(post.ismarking) {
      $scope.usersOnline[post.replyto_user] && ++$scope.usersOnline[post.replyto_user].balance;
      $scope.usersOnline[post.username] && --$scope.usersOnline[post.username].balance;
      $scope.posts[post.replyto] && ++$scope.posts[post.replyto].marks;
    }
    // Post is replying to user.
    if(post.replyto_user === $scope.data.username) {
      // Post is also marking user
      if(post.ismarking) ++$scope.data.balance;
      // no message so assume its a marking a pm.
      if(post.ismarking && !post.message) {
        for(let i = 0, l = $scope.pms.length; i < l; ++i) {
          // Post is marking user and user has pm window open with
          // the user creating the marking.
          if($scope.pms[i].username === post.username) {
            let ref = $scope.pms[i].history;
            for(let i = 0, l = ref.length; i < l; ++i) {
              // Post is marking users pm.
              if(post.replyto === ref[i]._id) {
                 ref[i].ismarked = true;
                 return
              }
            }
          }
        }
      }
      // Loop through user's notifications to check if post already has notifications.
      for(let i = 0, l = $scope.data.notifications.length; i < l; ++i) {
        // User already has notifications about this post, increment amount.
        if(post.replyto === $scope.data.notifications[i].id) return ++$scope.data.notifications[i].amount
      }
      // User doesnt have notifications about this post, add it.
      $scope.data.notifications.push({id: post.replyto, amount: 1, message: post.message})
    }
  });
  socket.on('private message data', populatePmWindow);
  socket.on('user logged in', user => $scope.usersOnline[user.username] = user);
  socket.on('user logged out', user => delete $scope.usersOnline[user]);
  socket.on('users online', usersOnline => $scope.usersOnline = usersOnline);

  $scope.$watch(scope => Object.keys(scope.usersOnline).length, (newVal, oldVal, scope) => scope.amountOnline = newVal)

  $scope.notificationClicked = notification => {
    $scope.select({'_id' : notification.id });
    for(let i = 0, l = $scope.data.notifications.length; i < l; ++i) {
      if(notification.id === $scope.data.notifications[i].id) {
        $scope.data.notifications.splice(i, 1);
        break
      }
    }
    $http.get('/bitmark/api/delete_notification/' + notification.id)
  };
  $scope.reasonBlur = post => {
    alert(1);
    $scope.cancel = false;
    $scope.isDisabled = true;
    $timeout(() => {
      $scope.isDisabled = false;
      if (!$scope.cancel) {
        $scope.data.message_needed[post._id] = false;
        $scope.mark(post)
      }
    }, 200)
  };
  $scope.closePmWindow = pm => {
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      if(pm === $scope.pms[i]) {
        $scope.pms.splice(i, 1);
      }
    }
    socket.emit('private message close', pm)
  };
  // Checks if the pms fit on the screen.
  $(window).on('resize', _.throttle(function () {
      $scope.$apply(function(){
        const PM_WINDOWS = $scope.pms.length;
        const PM_WIDTH = 300, SPACING = 10, USERLIST_WIDTH = 150;
        if(PM_WINDOWS * (PM_WIDTH + SPACING) + USERLIST_WIDTH > $window.innerWidth) {
          // pms dont fit, remove one.
          $scope.pms.shift()
        }
      });
  }, 200));
  // return true if we need to sip msg.
  $scope.skipSameMin = () => $scope.data.skipSameMins && $scope.data.skipSameMins--;
  // The getSameMin function groups all the msgs with the same min into 1 block then
  // it sets skipSameMins to the amount of msgs it grouped, so we can skip displaying them.
  $scope.getSameMin = (history, index) => {
    var results = [];
    var i = index;
    // While the next history element has the same minnute. So i represents, relative to index, the amount found.
    while(history[i+1] && $scope.sameMin(history[i].date, history[i+1].date) && history[i].sender === history[i+1].sender) {
      results.push(history[i].message + '\n');
      ++i;
    }
    if(i > index) {
      // The above while loop doesnt add the last i.
      results.push(history[i].message);
      // Make sure to skip over all the entries with same min
      // Since we are grouping them up into one next command.
      $scope.data.skipSameMins = results.length - 1;
      return results.join('');
   } else {
      // The next message is a diff min. so return msg alone.
      return history[index].message;
    }
  };
  // Returns true if prev and cur message have same day/min respectivly.
  $scope.sameDay = (prev, cur) => new Date(prev).getDay() === new Date(cur).getDay();
  $scope.sameMin = (prev, cur) => new Date(prev).getMinutes() === new Date(cur).getMinutes();

  $scope.togglePmWindow = pm => {
    // If pm open and dontMinimize is true return.
    if(pm.maximized && $scope.data.dontMinimize) { $scope.data.dontMinimize = false; return; }
    pm.maximized = !pm.maximized;
    pm.maximized && delete $scope.data.awaiting_pm[pm.username];
    // If pm is maxmized increase height and make sure they dont have awaiting pm notifications. Otherwise reduce height.
    //pm.maximized ? (pm.style.height = '348px') && delete $scope.data.awaiting_pm[pm.username] : pm.style.height = '34px';
    // Persist changes.
    socket.emit('private message toggle', pm)
  };
  function populatePmWindow(pms) {
    if(!pms[0]) return;
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      let pm = $scope.pms[i];
      // Loop through current pms and update only the right pm window.
      if(pms[0].receiver === pm.username || pms[0].sender === pm.username) {
        pm.history = pms
      }
    }
  }
  // Throttle here to improve performance if typing is nonstop.
  $scope.startedTyping = _.throttle(function(pm) {
    // pm.username is the person receiving the pm.
    const data = {user: pm.username, started: true}
    socket.emit('private_messages typing', data)
  }, 500);
  socket.on('private_messages typing', data => {
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      if(data.user === $scope.pms[i].username) {
        if(data.finished) {
           $scope.pms[i].istyping = false;
           if(TYPING_TIMER[data.user]) return $timeout.cancel(TYPING_TIMER[data.user])
        } else {
          return startTypingTimer(i);
        }
      }
    }
  })
  function startTypingTimer(index) {
      var ref = $scope.pms[index];
      ref.istyping = true;
      if(TYPING_TIMER[ref.username]) {
        $timeout.cancel(TYPING_TIMER[ref.username])
      }
      TYPING_TIMER[ref.username] = $timeout(() => ref.istyping = false, 3750)
  };
  $scope.openPmWindow = user => {
    const PM_WIDTH = 300, SPACING = 10, USERLIST_WIDTH = 150;
    const PM_WINDOWS = $scope.pms.length;
    for(let i = 0; i < PM_WINDOWS; ++i) {
      let pm = $scope.pms[i];
      if(user.username === pm.username) {
        // The window exists, and was minimized, so remove its notifications before we toggle it.
        pm.minimized && delete $scope.data.awaiting_pm[pm.username];
        $scope.togglePmWindow(pm);
        return
      }
    }
    if((PM_WINDOWS+1) * (PM_WIDTH + SPACING) + USERLIST_WIDTH > $window.innerWidth) {
      $scope.pms.shift()
    }
    pm = { text: '', history: [], maximized: true, istyping: false, username: user.username };
    $scope.pms.push(pm);
    socket.emit('private message open', pm)
  };
  $scope.markPm = pm => {
    socket.emit('mark private message', pm, marked => marked && (pm.ismarked = 1) && $scope.data.balance--)
  }
  $scope.mark = post => {
    post.marking_msg = $scope.data.marking_msg;
    $scope.data.marking_msg = '';
    $scope.data.balance && $scope.data.username !== post.username && $http.post('/bitmark/api/mark/', post).then(()=> --$scope.data.balance)
  };
  $scope.updateState = (path, state, scroll) => {
    scroll = scroll || 0;
    if(state === 'home' && $scope.replyto) state = $scope.replyto;
    $location.old = $location.state() || {};
    $location.new = {
      replyto: $scope.replyto,
      state: state,
      scrollto: scroll,
      // This little algo keeps track of the users original scroll position
      // should the user ever hit the big red X indicating back to home.
      allscrollto: !$location.old.replyto ? scroll : $location.old.allscrollto
    };
    if ($location.new.state === $location.old.state) return;
    state === 'home' && (state = '');
    $location.state($location.new).path(path + state);
  };
  $scope.select = post => {
    if($scope.replyto === post._id) return;
    $scope.replyto = $scope.state = post._id;
    document.cookie = 'state=' + post._id + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
    post.scrollto = document.documentElement.scrollTop || document.body.scrollTop
    $scope.updateState('/bitmark/post/', post._id, post.scrollto);
  };
  // Watch for location changes so we can apply state accordingly
  $scope.$on('$locationChangeSuccess', (_, __, ___, ____, oldstate) => {
    var state_data = $location.state()
    if (!state_data) return
    $scope.replyto = state_data.replyto;
    $scope.state = state_data.state;
    document.cookie = 'state=' + state_data.state + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
    if(!oldstate) oldstate = {}
    setTimeout(() => window.scrollTo(0, !state_data.replyto ? state_data.allscrollto : oldstate.scrollto || 0), 0)
  });
  $scope.postGlow = post => {
    return {  'box-shadow' : '0 0 ' + post.marks / 2 + 'px purple' };
  };
  $scope.mergeStyles = styles => {
    var obj = {};
    for(let i = 0, l = styles.length; i < l; ++i) {
      Object.assign(obj, styles[i]);
    }
    return obj;
  };
  $scope.back = post => {
    document.cookie = 'state=' + post.replyto + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
    if (post.replyto) {
      $scope.state = post.replyto;
      $scope.replyto = post.replyto;
      $scope.updateState('/bitmark/post/', post.replyto)
    } else {
      $scope.replyto = '';
      $scope.updateState('/bitmark/', 'home');
    }
  };
  socket.on('new private message', pm => {
    var found = false;
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
      if(pm.sender === $scope.pms[i].username || pm.receiver === $scope.pms[i].username) {
        $scope.pms[i].history.push(pm);
console.log(111) 
       $scope.pms[i].maximized && (found = true);
      }
    }
    if(!found) {
      let ref = $scope.data.awaiting_pm;
      ref[pm.sender] = ref[pm.sender] ? ++ref[pm.sender] : 1;
    }
  })
  $scope.createPm = ($event, message, username) => {
    $event.preventDefault();
    $event.target.value = '';
    // Used to indicate the pm is new.
    var sameMin = false;
    // Find pm window and get its most current pm.
    for(let i = 0, l = $scope.pms.length; i < l; ++i) {
     let pm = $scope.pms[i];
     // Pm window found.
     if(username === pm.username) {
        let last;
        if(last = pm.history[pm.history.length - 1]) {
          sameMin = new Date(last.date).getMinutes() === (new Date).getMinutes();
          break
        }
      }
    }
    socket.emit('new private message', {message: message, username: username, sameMin: sameMin})
  };
  $scope.create = $event => {
    // In case of error try again. Every once and a while theres
    // an error here, idk why, but this solves the problem.
    var tries = 0;
    if(!$scope.data.message.trim()) return;
    $event.preventDefault();
    $scope.data.message = '';
    $event.target.blur();
    $event.target.rows = 1;
    $http.post('/bitmark/api/create', { 'message': $scope.data.message, 'replyto': $scope.replyto }).then(res => {
      // Post created successfully.
    }).catch(err => {
      ++tries < 3 && $scope.create($event);
      // ERROR CREATING, TRYING AGAIN!
    })
  };
  $scope.cancelMarking = post => {
    $scope.data.message_needed[post._id] = false;
    $scope.data.marking_msg = '';
    $scope.cancel = true;
  };
  $scope.logout = () => {
    socket.emit('log out', {});
    document.cookie = 'login-cookie' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    document.cookie = 'state' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    window.location.href = '/bitmark';
  };
}])
.filter('reverse', () => {
  return items => {
    if (items) return items.slice().reverse()
  }
})
.directive('autoFocus', () => {
  return {
    link: {
      post: (scope, element) => { element[0].focus() }
    }
  }
})
.directive('autoscroll', () => {
   return {
     restrict: 'A',
     link: (scope, elem, attr) => {
       scope.$watch(() => {
         return elem[0].scrollHeight;
       }, (newVal, oldVal) => {
         // This directive is just for pms and
         // 275px is our pm initial size, so skip it.
         if (!newVal || newVal === '275px') return;
         elem[0].scrollTop = elem[0].scrollHeight
       })
     }
   }
})
.directive('loaded', () => {
   var navBarLoaded = false;
   return {
     restrict: 'A',
     link: (scope, elem, attr) => {
       scope.$watch(() => {
         try { return document.getElementById(attr.loaded).scrollHeight } catch(e) { return }
       }, (newVal, oldVal) => {
         // newVal - oldVal == 42 is a hack to fix bug: (textarea is sending 2 scrollheight updates when its drawn)
         if(!newVal || newVal - oldVal == 42 || (attr.loaded === 'navbar' && navBarLoaded)) return;
         if(!navBarLoaded) navBarLoaded = true;
         elem[0].style.paddingTop = newVal + 10 + 'px'
       })
     }
   }
})
.factory('socket', ['$rootScope', function ($rootScope) {
  const socket = io('/bitmark');
  return {
    on: function (eventName, callback) {
      socket.on(eventName, function () {
        const args = arguments;
        $rootScope.$apply(() => callback.apply(socket, args))
      })
    },
    emit: function (eventName, data, callback) {
      socket.emit(eventName, data, function () {
        const args = arguments;
        callback && $rootScope.$apply(() => callback.apply(socket, args))
      })
    }
  }
}]);
