angular.module('myApp', ['angularMoment', 'monospaced.elastic'])
.config(['$locationProvider', '$compileProvider', ($locationProvider, $compileProvider) => {
  // optimizations.
  $compileProvider.commentDirectivesEnabled(false);
  $compileProvider.cssClassDirectivesEnabled(false);
  $compileProvider.debugInfoEnabled(false);
  // ensure html5 is required
  $locationProvider.html5Mode({ enabled: true, requireBase: false })
}])
.controller('mainController', ['$scope', '$http', '$location', '$timeout', '$window', 'socket',
($scope, $http, $location, $timeout, $window, socket) => {
  //const socket = io('/bitmark');
  $scope.state = document.cookie.substr(document.cookie.indexOf("state")+6, document.cookie.indexOf(";")-6);
  $scope.data = {}; $scope.data.message_needed = {}; $scope.replyto = "";
  $scope.loaded = {}; $scope.data.message = ""; $scope.data.marking_msg = "";
  $scope.usersOnline = {}; $scope.amountOnline = 0; $scope.pms = [];
  $scope.pmMergeIndex = 0; $scope.allowIndex = false; $scope.innerWidth = $window.innerWidth;
  // Every time the script is requested load the information
  $http.get("/bitmark/api/posts").then((res) => { $scope.posts = res.data });
  $http.get("/bitmark/api/info").then((res) => {
    $scope.pms = res.data.private_messages;
    for(let i = 0, l = $scope.pms.length; i < l; i++) {
      socket.emit("need pm data", $scope.pms[i].user.username)
    }
    $scope.data = res.data;
    var amount = 0;
    // Loop through every notification, and add up the amounts per.
    for(i = 0, l = $scope.data.notifications.length; i < l; i++) {
     amount += $scope.data.notifications[i].amount;
    }
    $scope.notificationAmount = amount;
  });
  // Request the users online.
  socket.emit("users online", {});
  socket.on("new post", post => {
    $scope.posts.push(post)
    // Post is replying to user.
    if(post.replyto_user === $scope.data.username) {
      if(post.ismarking) $scope.data.balance++;
      if(!post.message) {
        for(let i = 0, l = $scope.pms.length; i < l; i++) {
          if($scope.pms[i].user.username === post.username) {
            let ref = $scope.pms[i].history;
            for(let j = 0, l2 = ref.length; j < l2; j++) {
              if(post.replyto === ref[j]._id.toString()) {
                 ref[j].ismarked = true;
                 return;
              }
            }
          }
        }
      }
      let found = false;
      // Loop through user's notifications to check if post already has notifications.
      for(let i = 0, l = $scope.data.notifications.length; i < l; i++) {
        // User already has notifications about this post, increment amount.
        if(post.replyto === $scope.data.notifications[i].id) {
          $scope.data.notifications[i].amount++;
          found = true
        }
      }
      // User doesnt have notifications about this post, add it.
      if(!found) $scope.data.notifications.push({id: post.replyto, amount: 1, message: post.message})
      // increment total notification counter.
      $scope.notificationAmount++
      // Post is marking user's pm.
    }
  });
  socket.on("needed pm data", updatePms)
  socket.on("user logged in", user => $scope.usersOnline[user.username] = user);
  socket.on("user logged out", user => delete $scope.usersOnline[user.username]);
  socket.on("users online", usersOnline => $scope.usersOnline = usersOnline);
  // New user notification.
  socket.on("new notification", notification => {
  });

  $scope.$watch(scope => Object.keys(scope.usersOnline).length, (newVal, oldVal, scope) => scope.amountOnline = newVal)

  $scope.notificationClicked = notification => {
window.n = $scope.data.notifications
    $scope.notificationAmount -= notification.amount;
    $scope.select({'_id' : notification.id });
    for(i = 0, l = $scope.data.notifications.length; i < l; i++) {
     if(notification.id === $scope.data.notifications[i].id) $scope.data.notifications.splice(i, 1)
    }
    $http.get("/bitmark/api/delete_notification/" + notification.id).then(()=>{})
  };
  $scope.reasonBlur = post => {
    $scope.cancel = false;
    $scope.isDisabled = true;
    $timeout(() => {
      $scope.isDisabled = false;
      if (!$scope.cancel) {
        $scope.data.message_needed[post._id] = false;
        $scope.mark(post)
      }
    }, 200)
  };
  const PM_WIDTH = 300;
  $scope.closePmWindow = pm => {
    var found;
    for(let i = 0, l = $scope.pms.length; i < l; i++) {
      if(pm === $scope.pms[i]) {
        $scope.pms.splice(i, 1);
        found = i;
      }
    }
    for(let i = found-1; i >= 0; i--) {
      rightOffset = parseInt($scope.pms[i].style.right.slice(0, -2));
      rightOffset -= PM_WIDTH + 10;
      $scope.pms[i].style.right = rightOffset + 'px';
    }
    socket.emit("private_messages change", $scope.pms)
  };
  // Checks
  $(window).on("resize", _.throttle(function () {
      $scope.$apply(function(){
        var len = $scope.pms.length;
        if((len) * PM_WIDTH + (len * 10) + 170 > $window.innerWidth) {
          $scope.pms.shift()
        }
      });
  }, 100));

  $scope.skipSameMin = () => {
    if($scope.data.skipSameMins) {
      $scope.data.skipSameMins--;
      return true;
    } else {
      return false;
    }
  };
  $scope.getSameMin = (history, index) => {
    var results = [];
    var i = index;
    while(history[i+1] && $scope.sameMin(history[i].date, history[i+1].date) && history[i].sender === history[i+1].sender) {
      results.push(history[i].message + "\n");
      i++;
    }
    if(i > index) {
      results.push(history[i].message);
      $scope.data.skipSameMins = results.length-1;
      return results.join('');
   } else {
      return history[index].message;
    }
  };
  $scope.sameDay = (one, two) => {
    one = new Date(one)
    two = new Date(two)
    return one.getDay() === two.getDay()
  };
  $scope.sameMin = (one, two) => {
    one = new Date(one)
    two = new Date(two)
    return one.getMinutes() === two.getMinutes()
  };
  $scope.togglePmWindow = pm => {
    pm.maximized = !pm.maximized;
    if(!pm.maximized) pm.style.height = "34px";
    else pm.style.height = "348px";
    socket.emit("private_messages change", $scope.pms)
  };
  function updatePms(pms) {
    if(!pms[0]) return;
    for(let i = 0, l = $scope.pms.length; i < l; i++) {
      if(pms[0].receiver === $scope.pms[i].user.username || pms[0].sender === $scope.pms[i].user.username) {
        $scope.pms[i].history = $scope.pms[i].history.concat(pms)
      }
    }
  }
  $scope.startedTyping = pm => {
    const data = {user: pm.user.username, started: true}
    socket.emit("private_messages typing", data)
  };
  socket.on("private_messages typing", data => {
    for(let i = 0, l = $scope.pms.length; i < l; i++) {
      if(data.user === $scope.pms[i].user.username) {
        if(data.finished) {
           $scope.pms[i].istyping = false;
           if(typingTimer[data.user]) $timeout.cancel(typingTimer[data.user])
        } else {
          return startTypingTimer(i);
        }
      }
    }
  })
  const typingTimer = {};
  function startTypingTimer(index) {
    var ref = $scope.pms[index];
    ref.istyping = true;
    if(typingTimer[ref.user.username]) {
      $timeout.cancel(typingTimer[ref.user.username])
    }
    typingTimer[ref.user.username] = $timeout(()=> {
      ref.istyping = false;
    }, 5750)
  };
  //openPmWindow
  $scope.privateMessage = user => {
    var PM_RIGHT = 0, len;
    if(len = $scope.pms.length) {
      for(let i = 0; i < len; i++) {
        if(user === $scope.pms[i].user) {
          // The window exists, so in the future come back
          // here and minimize/maximize the window.
          return;
        }
      }
    }
    socket.emit("need pm data", user.username)
    // 170 is the user-list width. len * 10 is spacing.
    if((len+1) * PM_WIDTH + (len * 10) + 170 > $window.innerWidth) {
      $scope.pms.shift()
      //return alert("To many windows!")
    }
    for(let i = 0, l = $scope.pms.length; i < l; i++) {
      rightOffset = parseInt($scope.pms[i].style.right.slice(0, -2));
      rightOffset += PM_WIDTH + 10;
      $scope.pms[i].style.right = rightOffset + 'px';
    }
    // 170 is the user-list width. len * 10 is spacing.
    PM_RIGHT = 170 + 10;
    var pm = {};
    pm.text = "";
    pm.history = [];
    pm.maximized = true;
    pm.istyping = false;
    pm.user = user;
    pm.style = { 'background-color': '#ffffff',  'border': '1px solid #b0b0b0', 'bottom': '0', 'display': 'none',
      'height': '348px', 'position': 'fixed', 'right': PM_RIGHT + 'px', 'width': '300px', 'font-family': "'Open Sans', sans-serif"
    }
    $scope.pms.push(pm)
    socket.emit("private_messages change", $scope.pms)
  };
  $scope.markPm = pm => {
    socket.emit("mark private message", pm, marked => marked && (pm.ismarked = 1))
  }
  $scope.mark = post => {
    $scope.data.message_needed[post._id] = false;
    post.marking_msg = $scope.data.marking_msg; $scope.data.marking_msg = "";
    $scope.data.username === post.username || $http.post("/bitmark/api/mark/", post).then(()=>{ $scope.data.balance-- });
  };
  $scope.updateState = (path, state, scroll) => {
    scroll = scroll || 0
    var cookie_state = state;
    if (state == 'home') {
      if ($scope.replyto.length === 24) cookie_state = $scope.replyto;
    }
    $location.old = $location.state({scrollto: scroll});
    $location.new = {
      selected_style: ($scope.replyto.length==24?{ 'width': '650px' }:''),
      replyto: $scope.replyto,
      state: cookie_state,
      scrollto: scroll
    };
    try { if ($location.new.state === $location.old.state) return; } catch(e) {} //Error is thrown first time page is loaded since $location.old is undefined.
    state === 'home' && (state = '');
    $location.state($location.new).path(path + state);
  };
  $scope.updateState("/bitmark/", "home");
  $scope.select = post => {
    if($scope.replyto === post._id) return;
    $scope.selected_style = {"width": "650px"};
    $scope.replyto = post._id;
    document.cookie = 'state=' + post._id + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    $scope.state = post._id;
    post.scrollto = document.documentElement.scrollTop || document.body.scrollTop
    $scope.updateState('/bitmark/post/', post._id, post.scrollto);
  };
  if ($scope.state.length === 24) $scope.select({'_id': $scope.state});
  // Watch for location changes so we can apply state accordingly
  $scope.$on('$locationChangeSuccess', (_, __, ___, ____, oldstate) => {
    var state_data = $location.state()
    if (!state_data) return
    $scope.selected_style = state_data.selected_style;
    $scope.replyto = state_data.replyto;
    $scope.state = state_data.state;
    document.cookie = 'state=' + state_data.state + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
    if(!oldstate) oldstate = {}
    setTimeout(() => {
      window.scrollTo(0, (oldstate.scrollto || 0));
    }, 0)
  });
  $scope.postGlow = post => {
    return {  "box-shadow" : "0 0 " + post.marks / 2 + "px purple" };
  };
  $scope.mergeStyles = styles => {
    var obj = {};
    for(let i = 0, l = styles.length; i < l; i++) {
      for(let key in styles[i]) obj[key] = styles[i][key];
    }
    return obj;
  };
  $scope.back = post => {
    document.cookie = 'state=' + post.replyto + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    if (post.replyto) {
      $scope.state = post.replyto;
      $scope.replyto = post.replyto;
      $scope.updateState('/bitmark/post/', post.replyto)
    } else {
      $scope.selected_style = "";
      $scope.replyto = "";
      $scope.updateState('/bitmark/', 'home');
    }
  };
  socket.on("new private message", pm => {
    for(let i = 0, l = $scope.pms.length; i < l; i++) {
      if(pm.sender === $scope.pms[i].user.username || pm.receiver === $scope.pms[i].user.username) {
        $scope.pms[i].history.push(pm)
      }
    }
  })
  $scope.createPm = ($event, message, username) => {
   $event.preventDefault();
    socket.emit("new private message", {message: message, username: username})
    $event.target.value = "";
  };
  $scope.create = $event => {
    $http.post("/bitmark/api/create", { 'message': $scope.data.message, 'replyto': $scope.replyto }).then(res => {
      $event.preventDefault();
      $scope.data.message = "";
      $event.target.blur();
      $event.target.rows = 1;
    }).catch(err => {$scope.create($event); console.log("ERROR CREATING, TRYING AGAIN!")})
  };
  $scope.cancelMarking = post => {
    $scope.data.message_needed[post._id] = false;
    data.marking_msg = '';
    $scope.cancel = true;
  };
  $scope.logout = () => {
    socket.emit("log out", {});
    document.cookie = 'login-cookie' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    document.cookie = 'state' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    window.location.href = "/bitmark";
  };
}])
.filter('reverse', () => {
  return items => {
    if (items) return items.slice().reverse();
  }
})
.directive('autoFocus', () => {
  return {
    link: {
      post: (scope, element) => { element[0].focus() }
    }
  }
})
.directive('autoscroll', () => {
   return {
     restrict: 'A',
     link: (scope, elem, attr) => {
       scope.$watch(() => {
         return elem[0].scrollHeight;
       }, (newVal, oldVal) => {
         if (!newVal || newVal === '275px') return;
         elem[0].scrollTop = elem[0].scrollHeight;
       });
     }
   }
})
.directive('loaded', () => {
   var navBarLoaded = false;
   return {
     restrict: 'A',
     link: (scope, elem, attr) => {
       scope.$watch(() => {
         try { return document.getElementById(attr.loaded).scrollHeight } catch(e) { return }
       }, (newVal, oldVal) => {
         if (!newVal) return;
         if(newVal - oldVal == 42) return; // Hack to fix bug: (textarea is sending 2 scrollheight updates when its drawn)
         if (attr.loaded == "navbar" && navBarLoaded) return;
         if (!navBarLoaded) navBarLoaded = true;
         elem[0].style.paddingTop = newVal + 10 + 'px';
       });
     }
   }
})
.factory('socket', ['$rootScope', function ($rootScope) {
  const socket = io('/bitmark');
  return {
    on: function (eventName, callback) {
      socket.on(eventName, function () {
        const args = arguments;
        $rootScope.$apply(function () {
          callback.apply(socket, args);
        });
      });
    },
    emit: function (eventName, data, callback) {
      socket.emit(eventName, data, function () {
        const args = arguments;
        $rootScope.$apply(function () {
          if (callback) {
            callback.apply(socket, args);
          }
        });
      })
    }
  };
}])

