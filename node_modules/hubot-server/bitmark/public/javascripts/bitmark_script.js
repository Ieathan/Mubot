angular.module('myApp', ['angularMoment', 'ngRoute'])

.config(function($locationProvider) {
  $locationProvider.html5Mode({ enabled: true, requireBase: false })
})
.controller('mainController', function($scope, $http, $interval, $timeout, $location) {
  $scope.state = document.cookie.substr(document.cookie.indexOf("state")+6, document.cookie.indexOf(";")-6);
  $scope.data = {}; $scope.message_needed = {}; $scope.replyto = ""; $scope.loaded = {}; $scope.isPadable = true; $scope.timerOn = false;

  // Every time the script is requested load the information
  $http.get("/bitmark/posts").then(function(res) { $scope.posts = res.data });
  $http.get("/bitmark/info").then(function(res) { $scope.data = res.data });

  // Also load the information using an interval timer, set the header to "lont-log" to avoid logger spam.
  var posts_req = { method: 'GET', url: '/bitmark/posts', headers: { 'dont-log': "This wont be logged by the server" } }
  var info_req  = { method: 'GET', url: '/bitmark/info',  headers: { 'dont-log': "This wont be logged by the server" } }
  $interval(function(){
    $http(posts_req).then(function(res) {
      $scope.posts = res.data;
    })
  }, 1500);
  $interval(function(){
    $http(info_req).then(function(res) {
      $scope.data = res.data;
    })
  }, 2000);
  $scope.notificationClicked = function(notification) {
    $scope.select({'_id' : notification.id });
    $http.get("/bitmark/delete_notification/" + notification.id).then(function(res) {})
  };
  $scope.reasonBlur = function (post) {
    $scope.cancel = false;
    $scope.isDisabled = true;
    $timeout(function() {
      $scope.isDisabled = false;
      if (!$scope.cancel) {
        $scope.message_needed[post._id] = false;
        $scope.mark(post)
      }
    }, 200)
  };
  $scope.mark = function (post) {
    $scope.message_needed[post._id] = false;
    post.marking_msg = $scope.marking_msg; $scope.marking_msg = "";
    $scope.data.username == post.username || $http.post("/bitmark/mark/", post).then(function(){ $scope.balance--; });
  };
  $scope.updateState = function (path, state, scroll) {
    scroll = scroll || 0
    var cookie_state = state;
    if (state == 'home') {
      if ($scope.replyto.length == 24) cookie_state = $scope.replyto;
    }
    $location.old = $location.state({scrollto: scroll});
    $location.new = {
      selected_style: ($scope.replyto.length==24?{ 'width': '650px' }:''),
      replyto: $scope.replyto, //(state.length==24?state:$scope.replyto),
      state: cookie_state,
      scrollto: scroll
    };
    try { if ($location.new.state === $location.old.state) return; } catch(e) {} //Error is thrown first time page is loaded since $location.old is undefined.
    state == 'home' && (state = '');
    $location.state($location.new).path(path + state);
  };
  $scope.updateState("/", "home");
  $scope.select = function (post) {
    $scope.selected_style = {"width": "650px"};
    $scope.replyto = post._id;
    document.cookie = 'state=' + post._id + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    $scope.state = post._id;
    post.scrollto = document.documentElement.scrollTop || document.body.scrollTop
    $scope.updateState('/bitmark/posts/', post._id, post.scrollto);
  };
  if ($scope.state.length === 24) $scope.select({'_id': $scope.state});
  // Watch for location changes so we can apply state accordingly
  $scope.$on('$locationChangeSuccess', function (a, b, c, d, oldstate) {
//    console.log($location.state())
    var state_data = $location.state()
    if (state_data == null) return
    $scope.selected_style = state_data.selected_style;
    $scope.replyto = state_data.replyto;
    $scope.state = state_data.state;
    document.cookie = 'state=' + state_data.state + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
//    console.log("SCROLLING TO " + oldstate.scrollto)
    setTimeout(function(){
      window.scrollTo(0, (oldstate.scrollto||0));
    }, 0)
  });
  $scope.stopPad = function() {
    $scope.isPadable = false;
    try { $timeout.cancel(t); } catch(e){}
    t = $timeout(function(){$scope.isPadable=true}, 500)
  };
  $scope.postGlow = function (post) {
    return {  "box-shadow" : "0 0 " + post.marks / 2 + "px purple" };
  };
  $scope.mergeStyles = function(objectList) {
    var obj = {};
    objectList.forEach(function(x) {
      for (var i in x)
        obj[i] = x[i];
    });
    return obj;
  };
  $scope.notificationAmount = function () {
    var amount = 0;
    $scope.data.notifications.forEach(function(n) { amount += n.amount });
    return amount
  };
  $scope.back = function(post) {
    document.cookie = 'state=' + post.replyto + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    if (post.replyto) {
      $scope.state = post.replyto;
      $scope.replyto = post.replyto;
      $scope.updateState('/bitmark/posts/', post.replyto)
    } else {
      $scope.selected_style = ""; $scope.replyto = "";
      $scope.updateState('/bitmark/', 'home');
    }
  };
  $scope.create = function ($event) {
    $http.post("/bitmark/create", { 'message': $scope.message, 'replyto': $scope.replyto }).then(function(res) {
      $scope.message = ""; $event.target.blur(); $event.target.rows = 1;
    })
  };
  $scope.cancelMarking = function(post) {
    $scope.message_needed[post._id] = false; $scope.marking_msg = ''; $scope.cancel = true;
  };
  $scope.logout = function() {
    document.cookie = 'login-cookie' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    document.cookie = 'state' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    window.location.href = "/";
  };
}).filter('reverse', function() {
  return function(items) {
    if (typeof items !== 'undefined') {
      return items.slice().reverse();
    }
  }
}).directive('autoFocus', function() {
  return {
    link: {
      post: function (scope, element, attr) { element[0].focus() }
    }
  }
 }).directive('loaded', function($timeout){
   return {
     restrict: 'A',
     link: function(scope, elem, attr) {
       scope.$watch(function () {
         try { return document.getElementById(attr.loaded).scrollHeight } catch(e) { return }
       }, function (newVal) {
         if (!newVal) return;
         if (scope.isPadable) elem[0].style.paddingTop = newVal + 10 + 'px'
       })
     }
   }
});
