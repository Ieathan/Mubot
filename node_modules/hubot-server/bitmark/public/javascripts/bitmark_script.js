angular.module('myApp', ['angularMoment', 'ngRoute'])

.config(($locationProvider) => {
  $locationProvider.html5Mode({ enabled: true, requireBase: false })
})
.controller('mainController', ($scope, $http, $interval, $timeout, $location) => {
  $scope.state = document.cookie.substr(document.cookie.indexOf("state")+6, document.cookie.indexOf(";")-6);
  $scope.data = {}; $scope.message_needed = {}; $scope.replyto = ""; $scope.loaded = {}; $scope.isPadable = true; $scope.timerOn = false;

  // Every time the script is requested load the information
  $http.get("/bitmark/api/posts").then((res) => { $scope.posts = res.data });
  $http.get("/bitmark/api/info").then((res) => { $scope.data = res.data });

  // Also load the information using an interval timer, set the header to "lont-log" to avoid logger spam.
  var posts_req = { method: 'GET', url: '/bitmark/api/posts', headers: { 'dont-log': "This wont be logged by the server" } }
  var info_req  = { method: 'GET', url: '/bitmark/api/info',  headers: { 'dont-log': "This wont be logged by the server" } }
  $interval(() => {
    $http(posts_req).then((res) => {
      $scope.posts = res.data;
    })
  }, 1500);
  $interval(() => {
    $http(info_req).then((res) => {
      $scope.data = res.data;
    })
  }, 2000);
  $scope.notificationClicked = (notification) => {
    $scope.select({'_id' : notification.id });
    $http.get("/bitmark/api/delete_notification/" + notification.id).then(()=>{})
  };
  $scope.reasonBlur =  (post) => {
    $scope.cancel = false;
    $scope.isDisabled = true;
    $timeout(() => {
      $scope.isDisabled = false;
      if (!$scope.cancel) {
        $scope.message_needed[post._id] = false;
        $scope.mark(post)
      }
    }, 200)
  };
  $scope.mark = (post) => {
    $scope.message_needed[post._id] = false;
    post.marking_msg = $scope.marking_msg; $scope.marking_msg = "";
    $scope.data.username == post.username || $http.post("/bitmark/api/mark/", post).then(()=>{ $scope.balance--; });
  };
  $scope.updateState =  (path, state, scroll) => {
    scroll = scroll || 0
    var cookie_state = state;
    if (state == 'home') {
      if ($scope.replyto.length == 24) cookie_state = $scope.replyto;
    }
    $location.old = $location.state({scrollto: scroll});
    $location.new = {
      selected_style: ($scope.replyto.length==24?{ 'width': '650px' }:''),
      replyto: $scope.replyto, //(state.length==24?state:$scope.replyto),
      state: cookie_state,
      scrollto: scroll
    };
    try { if ($location.new.state === $location.old.state) return; } catch(e) {} //Error is thrown first time page is loaded since $location.old is undefined.
    state == 'home' && (state = '');
    $location.state($location.new).path(path + state);
  };
  $scope.updateState("/bitmark/", "home");
  $scope.select = (post) => {
    $scope.selected_style = {"width": "650px"};
    $scope.replyto = post._id;
    document.cookie = 'state=' + post._id + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    $scope.state = post._id;
    post.scrollto = document.documentElement.scrollTop || document.body.scrollTop
    $scope.updateState('/bitmark/post/', post._id, post.scrollto);
  };
  if ($scope.state.length === 24) $scope.select({'_id': $scope.state});
  // Watch for location changes so we can apply state accordingly
  $scope.$on('$locationChangeSuccess', (_, __, ___, ____, oldstate) => {
    var state_data = $location.state()
    if (state_data == null) return
    $scope.selected_style = state_data.selected_style;
    $scope.replyto = state_data.replyto;
    $scope.state = state_data.state;
    document.cookie = 'state=' + state_data.state + '; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;';
    if(typeof oldstate == 'undefined') oldstate = {}
    setTimeout(()=>{
      window.scrollTo(0, (oldstate.scrollto || 0));
    }, 0)
  });
  $scope.stopPad = () => {
    $scope.isPadable = false;
    if (t) { $timeout.cancel(t); $scope.isPadable = true; }
    t = $timeout(()=>{$scope.isPadable=true}, 500)
  };
  $scope.postGlow = (post) => {
    return {  "box-shadow" : "0 0 " + post.marks / 2 + "px purple" };
  };
  $scope.mergeStyles = (objectList) => {
    var obj = {};
    objectList.forEach((x) => {
      for (var i in x)
        obj[i] = x[i];
    });
    return obj;
  };
  $scope.notificationAmount = () => {
    var amount = 0;
    $scope.data.notifications.forEach((n) => { amount += n.amount });
    return amount
  };
  $scope.back = (post) => {
    document.cookie = 'state=' + post.replyto + "; expires=Thu, 01 Jan 2222 00:00:01 GMT; path=/;";
    if (post.replyto) {
      $scope.state = post.replyto;
      $scope.replyto = post.replyto;
      $scope.updateState('/bitmark/post/', post.replyto)
    } else {
      $scope.selected_style = ""; $scope.replyto = "";
      $scope.updateState('/bitmark/', 'home');
    }
  };
  $scope.create = ($event) => {
    $http.post("/bitmark/api/create", { 'message': $scope.message, 'replyto': $scope.replyto }).then((res) => {
      $scope.message = ""; $event.target.blur(); $event.target.rows = 1;
    })
  };
  $scope.cancelMarking = (post) => {
    $scope.message_needed[post._id] = false; $scope.marking_msg = ''; $scope.cancel = true;
  };
  $scope.logout = () => {
    document.cookie = 'login-cookie' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    document.cookie = 'state' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;';
    window.location.href = "/bitmark";
  };
}).filter('reverse', () => {
  return (items) => {
    if (typeof items !== 'undefined') {
      return items.slice().reverse();
    }
  }
}).directive('autoFocus', () => {
  return {
    link: {
      post: (scope, element, attr) => { element[0].focus() }
    }
  }
 }).directive('loaded', ($timeout) => {
   return {
     restrict: 'A',
     link: (scope, elem, attr) => {
       scope.$watch(() => {
         try { return document.getElementById(attr.loaded).scrollHeight } catch(e) { return }
       }, (newVal) => {
         if (!newVal) return;
         if (scope.isPadable) { elem[0].style.paddingTop = newVal + 10 + 'px' }
       })
     }
   }
});
