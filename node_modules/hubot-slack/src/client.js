// Generated by CoffeeScript 1.12.6
(function() {
  var MemoryDataStore, RtmClient, SLACK_CLIENT_OPTIONS, SlackClient, SlackFormatter, WebClient, _, ref;

  ref = require('@slack/client'), RtmClient = ref.RtmClient, WebClient = ref.WebClient, MemoryDataStore = ref.MemoryDataStore;

  SlackFormatter = require('./formatter');

  _ = require('lodash');

  SLACK_CLIENT_OPTIONS = {
    dataStore: new MemoryDataStore()
  };

  SlackClient = (function() {
    function SlackClient(options, bot) {
      _.merge(SLACK_CLIENT_OPTIONS, options);
      this.bot = bot;
      this.rtm = new RtmClient(options.token, options);
      this.web = new WebClient(options.token, options);
      this.format = new SlackFormatter(this.rtm.dataStore);
      this.listeners = [];
    }


    /*
    Open connection to the Slack RTM API
     */

    SlackClient.prototype.connect = function() {
      return this.rtm.login();
    };


    /*
    Slack RTM event delegates
     */

    SlackClient.prototype.on = function(name, callback) {
      this.listeners.push(name);
      if (name === "message") {
        return this.rtm.on(name, (function(_this) {
          return function(message) {
            var bot_id, channel, user;
            user = message.user, channel = message.channel, bot_id = message.bot_id;
            message.text = _this.format.incoming(message);
            if (user) {
              message.user = _this.rtm.dataStore.getUserById(user);
            }
            if (bot_id) {
              message.bot = _this.rtm.dataStore.getBotById(bot_id);
            }
            if (channel) {
              message.channel = _this.rtm.dataStore.getChannelGroupOrDMById(channel);
            }
            return callback(message);
          };
        })(this));
      } else {
        return this.rtm.on(name, callback);
      }
    };


    /*
    Disconnect from the Slack RTM API and remove all listeners
     */

    SlackClient.prototype.disconnect = function() {
      var i, len, name, ref1;
      ref1 = this.listeners;
      for (i = 0, len = ref1.length; i < len; i++) {
        name = ref1[i];
        this.rtm.removeListener(name);
      }
      return this.listeners = [];
    };


    /*
    Set a channel's topic
     */

    SlackClient.prototype.setTopic = function(id, topic) {
      var channel, type;
      channel = this.rtm.dataStore.getChannelGroupOrDMById(id);
      this.bot.logger.debug(topic);
      type = channel.getType();
      switch (type) {
        case "channel":
          return this.web.channels.setTopic(id, topic);
        case "group":
          return this.web.groups.setTopic(id, topic, (function(_this) {
            return function(err, res) {
              if (err || !res.ok) {
                return _this.bot.logger.debug("Cannot set topic in MPIM");
              }
            };
          })(this));
        default:
          return this.bot.logger.debug("Cannot set topic in " + type);
      }
    };


    /*
    Send a message to Slack using the best client for the message type
     */

    SlackClient.prototype.send = function(envelope, message) {
      var options, ref1, room;
      if (envelope.room) {
        room = envelope.room;
      } else if (envelope.id) {
        room = envelope.id;
      }
      this.bot.logger.debug("Sending to " + room + ": " + message);
      options = {
        as_user: true,
        link_names: 1,
        thread_ts: (ref1 = envelope.message) != null ? ref1.thread_ts : void 0
      };
      if (typeof message !== 'string') {
        return this.web.chat.postMessage(room, message.text, _.defaults(message, options));
      } else {
        return this.web.chat.postMessage(room, message, options);
      }
    };

    return SlackClient;

  })();

  module.exports = SlackClient;

}).call(this);
