// Generated by CoffeeScript 1.12.6
(function() {
  var Adapter, CatchAllMessage, EnterMessage, LeaveMessage, Message, ReactionMessage, Robot, SlackBot, SlackClient, TextMessage, TopicMessage, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require('hubot'), Adapter = ref.Adapter, TextMessage = ref.TextMessage, EnterMessage = ref.EnterMessage, LeaveMessage = ref.LeaveMessage, TopicMessage = ref.TopicMessage, Message = ref.Message, CatchAllMessage = ref.CatchAllMessage, Robot = ref.Robot;

  SlackClient = require('./client');

  ReactionMessage = require('./reaction-message');

  Robot.prototype.react = function(matcher, options, callback) {
    var matchReaction;
    matchReaction = function(msg) {
      return msg instanceof ReactionMessage;
    };
    if (arguments.length === 1) {
      return this.listen(matchReaction, matcher);
    } else if (matcher instanceof Function) {
      matchReaction = function(msg) {
        return msg instanceof ReactionMessage && matcher(msg);
      };
    } else {
      callback = options;
      options = matcher;
    }
    return this.listen(matchReaction, options, callback);
  };

  SlackBot = (function(superClass) {
    extend(SlackBot, superClass);

    function SlackBot(robot, options1) {
      this.robot = robot;
      this.options = options1;
      this.userChange = bind(this.userChange, this);
      this.loadUsers = bind(this.loadUsers, this);
      this.reaction = bind(this.reaction, this);
      this.message = bind(this.message, this);
      this.error = bind(this.error, this);
      this.close = bind(this.close, this);
      this.authenticated = bind(this.authenticated, this);
      this.open = bind(this.open, this);
      this.client = new SlackClient(this.options, this.robot);
    }


    /*
    Slackbot initialization
     */

    SlackBot.prototype.run = function() {
      var ref1;
      if (!this.options.token) {
        return this.robot.logger.error("No service token provided to Hubot");
      }
      if (!((ref1 = this.options.token.substring(0, 5)) === 'xoxb-' || ref1 === 'xoxp-')) {
        return this.robot.logger.error("Invalid service token provided, please follow the upgrade instructions");
      }
      this.client.on('open', this.open);
      this.client.on('close', this.close);
      this.client.on('error', this.error);
      this.client.on('message', this.message);
      this.client.on('reaction_added', this.reaction);
      this.client.on('reaction_removed', this.reaction);
      this.client.on('authenticated', this.authenticated);
      this.client.on('user_change', this.userChange);
      this.client.web.users.list(this.loadUsers);
      this.robot.brain.on('loaded', (function(_this) {
        return function() {
          return _this.client.web.users.list(_this.loadUsers);
        };
      })(this));
      return this.client.connect();
    };


    /*
    Slack client has opened the connection
     */

    SlackBot.prototype.open = function() {
      this.robot.logger.info('Slack client now connected');
      return this.emit("connected");
    };


    /*
    Slack client has authenticated
     */

    SlackBot.prototype.authenticated = function(identity) {
      var i, len, ref1, team, user;
      this.self = identity.self, team = identity.team;
      ref1 = identity.users;
      for (i = 0, len = ref1.length; i < len; i++) {
        user = ref1[i];
        if (user.id === this.self.id) {
          this.self.bot_id = user.profile.bot_id;
          break;
        }
      }
      this.robot.name = this.self.name;
      return this.robot.logger.info("Logged in as " + this.robot.name + " of " + team.name);
    };


    /*
    Slack client has closed the connection
     */

    SlackBot.prototype.close = function() {
      if (this.options.autoReconnect) {
        return this.robot.logger.info('Slack client closed, waiting for reconnect');
      } else {
        this.robot.logger.info('Slack client connection was closed, exiting hubot process');
        this.client.disconnect();
        return process.exit(1);
      }
    };


    /*
    Slack client received an error
     */

    SlackBot.prototype.error = function(error) {
      if (error.code === -1) {
        return this.robot.logger.warning("Received rate limiting error " + (JSON.stringify(error)));
      }
      return this.robot.emit('error', error);
    };


    /*
    Hubot is sending a message to Slack
     */

    SlackBot.prototype.send = function() {
      var envelope, i, len, message, messages, sent_messages;
      envelope = arguments[0], messages = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      sent_messages = [];
      for (i = 0, len = messages.length; i < len; i++) {
        message = messages[i];
        if (message !== '') {
          sent_messages.push(this.client.send(envelope, message));
        }
      }
      return sent_messages;
    };


    /*
    Hubot is replying to a Slack message
     */

    SlackBot.prototype.reply = function() {
      var envelope, i, len, message, messages, sent_messages;
      envelope = arguments[0], messages = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      sent_messages = [];
      for (i = 0, len = messages.length; i < len; i++) {
        message = messages[i];
        if (message !== '') {
          if (envelope.room[0] !== 'D') {
            message = "<@" + envelope.user.id + ">: " + message;
          }
          this.robot.logger.debug("Sending to " + envelope.room + ": " + message);
          sent_messages.push(this.client.send(envelope, message));
        }
      }
      return sent_messages;
    };


    /*
    Hubot is setting the Slack channel topic
     */

    SlackBot.prototype.setTopic = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (envelope.room[0] === 'D') {
        return;
      }
      return this.client.setTopic(envelope.room, strings.join("\n"));
    };


    /*
    Message received from Slack
     */

    SlackBot.prototype.message = function(message) {
      var bot, channel, subtype, text, textMessage, topic, user;
      text = message.text, user = message.user, channel = message.channel, subtype = message.subtype, topic = message.topic, bot = message.bot;
      if (user && (user.id === this.self.id)) {
        return;
      }
      if (bot && (bot.id === this.self.bot_id)) {
        return;
      }
      subtype = subtype || 'message';
      if (bot) {
        user = bot;
      }
      if (user) {
        user = user;
      }
      if (!user && !bot) {
        user = {};
      }
      user.room = channel.id;
      if (channel.id[0] === 'D') {
        text = this.robot.name + " " + text;
        if (channel.name == null) {
          channel.name = channel._modelName;
        }
      }
      switch (subtype) {
        case 'message':
        case 'bot_message':
          this.robot.logger.debug("Received message: '" + text + "' in channel: " + channel.name + ", from: " + user.name);
          textMessage = new TextMessage(user, text, message.ts);
          textMessage.thread_ts = message.thread_ts;
          return this.receive(textMessage);
        case 'channel_join':
        case 'group_join':
          this.robot.logger.debug(user.name + " has joined " + channel.name);
          return this.receive(new EnterMessage(user));
        case 'channel_leave':
        case 'group_leave':
          this.robot.logger.debug(user.name + " has left " + channel.name);
          return this.receive(new LeaveMessage(user));
        case 'channel_topic':
        case 'group_topic':
          this.robot.logger.debug(user.name + " set the topic in " + channel.name + " to " + topic);
          return this.receive(new TopicMessage(user, message.topic, message.ts));
        default:
          this.robot.logger.debug("Received message: '" + text + "' in channel: " + channel.name + ", subtype: " + subtype);
          message.user = user;
          return this.receive(new CatchAllMessage(message));
      }
    };


    /*
    Reaction added/removed event received from Slack
     */

    SlackBot.prototype.reaction = function(message) {
      var event_ts, item, item_user, reaction, type, user;
      type = message.type, user = message.user, reaction = message.reaction, item_user = message.item_user, item = message.item, event_ts = message.event_ts;
      if ((user === this.self.id) || (user === this.self.bot_id)) {
        return;
      }
      user = this.client.rtm.dataStore.getUserById(user);
      item_user = this.client.rtm.dataStore.getUserById(item_user);
      if (!(user && item_user)) {
        return;
      }
      user.room = item.channel;
      return this.receive(new ReactionMessage(type, user, reaction, item_user, item, event_ts));
    };

    SlackBot.prototype.loadUsers = function(err, res) {
      var i, len, member, ref1, results;
      if (err || !res.ok) {
        this.robot.logger.error("Can't fetch users");
        return;
      }
      ref1 = res.members;
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        member = ref1[i];
        results.push(this.userChange(member));
      }
      return results;
    };

    SlackBot.prototype.userChange = function(event_or_user) {
      var key, newUser, ref1, user, value;
      if (!event_or_user) {
        return;
      }
      user = event_or_user.type === 'user_change' ? event_or_user.user : event_or_user;
      newUser = {
        id: user.id,
        name: user.name,
        real_name: user.real_name,
        slack: {}
      };
      if (user.profile && user.profile.email) {
        newUser.email_address = user.profile.email;
      }
      for (key in user) {
        value = user[key];
        if (value instanceof SlackClient) {
          continue;
        }
        newUser.slack[key] = value;
      }
      if (user.id in this.robot.brain.data.users) {
        ref1 = this.robot.brain.data.users[user.id];
        for (key in ref1) {
          value = ref1[key];
          if (!(key in newUser)) {
            newUser[key] = value;
          }
        }
      }
      delete this.robot.brain.data.users[user.id];
      return this.robot.brain.userForId(user.id, newUser);
    };

    return SlackBot;

  })(Adapter);

  module.exports = SlackBot;

}).call(this);
