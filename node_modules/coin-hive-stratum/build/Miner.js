var EventEmitter = require("events");
var uuid = require("uuid");
var Queue = require("./Queue");
var Metrics = require("./Metrics");
function Miner(options) {
		EventEmitter.call(this)
    this.id = uuid.v4();
    this.login = null;
    this.address = null;
    this.user = null;
    this.diff = null;
    this.pass = null;
    this.heartbeat = null;
    this.connection = null;
    this.queue = new Queue();
    this.ws = null;
    this.online = false;
    this.jobs = [];
    this.hashes = 0;
    this.connection = options.connection;
    this.ws = options.ws;
    this.address = options.address;
    this.user = options.user;
    this.diff = options.diff;
    this.pass = options.pass;
    return this;
}
Miner.prototype = Object.create(EventEmitter.prototype);
Miner.prototype.constructor = Miner;

Miner.prototype.connect = function () {
    var _this = this;
    console.log("miner connected (" + this.id + ")");
    Metrics.minersCounter.inc();
    this.ws.on("message", this.handleMessage.bind(this));
    this.ws.on("close", function () {
        if (_this.online) {
            console.log("miner connection closed (" + _this.id + ")");
            _this.kill();
        }
    });
    this.ws.on("error", function (error) {
        if (_this.online) {
            console.log("miner connection error (" + _this.id + "):", error.message);
            _this.kill();
        }
    });
    this.connection.addMiner(this);
    this.connection.on(this.id + ":authed", this.handleAuthed.bind(this));
    this.connection.on(this.id + ":job", this.handleJob.bind(this));
    this.connection.on(this.id + ":accepted", this.handleAccepted.bind(this));
    this.connection.on(this.id + ":error", this.handleError.bind(this));
    this.queue.on("message", function (message) {
        return _this.connection.send(_this.id, message.method, message.params);
    });
    this.heartbeat = setInterval(function () { return _this.connection.send(_this.id, "keepalived"); }, 30000);
    this.online = true;

    if (this.online) {
        this.queue.start();
        console.log("miner started (" + this.id + ")");
        this.emit("open", {
            id: this.id
        });
    }
};
Miner.prototype.kill = function () {
    this.queue.stop();
    this.connection.removeMiner(this.id);
    this.connection.removeAllListeners(this.id + ":authed");
    this.connection.removeAllListeners(this.id + ":job");
    this.connection.removeAllListeners(this.id + ":accepted");
    this.connection.removeAllListeners(this.id + ":error");
    this.jobs = [];
    this.hashes = 0;
    this.ws.close();
    if (this.heartbeat) {
        clearInterval(this.heartbeat);
        this.heartbeat = null;
    }
    if (this.online) {
        this.online = false;
        Metrics.minersCounter.dec();
        console.log("miner disconnected (" + this.id + ")");
        this.emit("close", {
            id: this.id,
            login: this.login
        });
    }
    this.removeAllListeners();
};
Miner.prototype.sendToMiner = function (payload) {
    var coinhiveMessage = JSON.stringify(payload);
    if (this.online) {
        try {
            this.ws.send(coinhiveMessage);
        }
        catch (e) {
            this.kill();
        }
    }
};
Miner.prototype.sendToPool = function (method, params) {
    this.queue.push({
        type: "message",
        payload: {
            method: method,
            params: params
        }
    });
};
Miner.prototype.handleAuthed = function (auth) {
    console.log("miner authenticated (" + this.id + "):", auth);
    this.sendToMiner({
        type: "authed",
        params: {
            token: "",
            hashes: 0
        }
    });
    this.emit("authed", {
        id: this.id,
        login: this.login,
        auth: auth
    });
};
Miner.prototype.handleJob = function (job) {
    var _this = this;
    console.log("job arrived (" + this.id + "):", job.job_id);
    this.jobs.push(job);

    this.sendToMiner({
        type: "job",
        params: this.jobs.pop()
    });

    this.emit("job", {
        id: this.id,
        login: this.login,
        job: job
    });
};
Miner.prototype.handleAccepted = function (job) {
    this.hashes++;
    console.log("shares accepted (" + this.id + "):", this.hashes);
    Metrics.sharesCounter.inc();
    Metrics.sharesMeter.mark();
    this.sendToMiner({
        type: "hash_accepted",
        params: {
            hashes: this.hashes
        }
    });
    this.emit("accepted", {
        id: this.id,
        login: this.login,
        hashes: this.hashes
    });
};
Miner.prototype.handleError = function (error) {
    console.warn("pool connection error (" + this.id + "):", error.error || (error && JSON.stringify(error)) || "unknown error");
    this.sendToMiner({
        type: "error",
        params: error
    });
    this.emit("error", {
        id: this.id,
        login: this.login,
        error: error
    });
    this.kill();
};
Miner.prototype.handleMessage = function (message) {
    var data;
    try {
        data = JSON.parse(message);
    }
    catch (e) {
        console.warn("can't parse message as JSON from miner:", message, e.message);
        return;
    }
    switch (data.type) {
        case "auth": {
            var params = data.params;
            this.login = this.address || params.site_key;
            var user = this.user || params.user;
            if (user) {
                this.login += "." + user;
            }
            if (this.diff) {
                this.login += "+" + this.diff;
            }
            this.sendToPool("login", {
                login: this.login,
                pass: this.pass
            });
            break;
        }
        case "submit": {
            var job = data.params;
            console.log("job submitted (" + this.id + "):", job.job_id);
            this.sendToPool("submit", job);

            this.emit("found", {
                id: this.id,
                login: this.login,
                job: job
            });
            break;
        }
    }
};

module.exports = Miner;
