var EventEmitter = require("events");
var WebSocket = require("ws");
var url = require("url");
var http = require("http");
var https = require("https");
var defaults = require("../config/defaults");
var Connection_1 = require("./Connection");
var Miner_1 = require("./Miner");
var Donation_1 = require("./Donation");

    function Proxy(constructorOptions) {
        EventEmitter.call(this);
        if (constructorOptions === void 0) { constructorOptions = defaults; }
        this.host = null;
        this.port = null;
        this.pass = null;
        this.ssl = null;
        this.address = null;
        this.user = null;
        this.diff = null;
        this.dynamicPool = false;
        this.maxMinersPerConnection = 100;
        this.donations = [];
        this.connections = {};
        this.wss = null;
        this.key = null;
        this.cert = null;
        this.path = null;
        this.server = null;
        this.credentials = null;
        var options = Object.assign({}, defaults, constructorOptions);
        this.host = options.host;
        this.port = options.port;
        this.pass = options.pass;
        this.ssl = options.ssl;
        this.address = options.address;
        this.user = options.user;
        this.diff = options.diff;
        this.dynamicPool = options.dynamicPool;
        this.maxMinersPerConnection = options.maxMinersPerConnection;
        this.donations = options.donations;
        this.key = options.key;
        this.cert = options.cert;
        this.path = options.path;
        this.server = options.server;
        this.credentials = options.credentials;
        this.constant = options.constant;
        this.on("error", function () {
            /* prevent unhandled error events from stopping the proxy */
        });
        return this;
    }
    Proxy.prototype = Object.create(EventEmitter.prototype);
    Proxy.prototype.constructor = Proxy;

    Proxy.prototype.listen = function (port, host, callback) {
        var _this = this;
        // create server
        var isHTTPS = !!(this.key && this.cert);
        if (!this.server) {
            var stats = function (req, res) {
                if (_this.credentials) {
                    var auth = require("basic-auth")(req);
                    if (!auth || auth.name !== _this.credentials.user || auth.pass !== _this.credentials.pass) {
                        res.statusCode = 401;
                        res.setHeader("WWW-Authenticate", 'Basic realm="Access to stats"');
                        res.end("Access denied");
                        return;
                    }
                }
                var url = require("url").parse(req.url);
                var proxyStats = _this.getStats();
                var body = JSON.stringify({
                    code: 404,
                    error: "Not Found"
                });
                if (url.pathname === "/stats") {
                    body = JSON.stringify({
                        miners: proxyStats.miners.length,
                        connections: proxyStats.connections.length
                    }, null, 2);
                }
                if (url.pathname === "/miners") {
                    body = JSON.stringify(proxyStats.miners, null, 2);
                }
                if (url.pathname === "/connections") {
                    body = JSON.stringify(proxyStats.connections, null, 2);
                }
                res.writeHead(200, {
                    "Content-Length": Buffer.byteLength(body),
                    "Content-Type": "application/json"
                });
                res.end(body);
            };
            if (isHTTPS) {
                var certificates = {
                    key: this.key,
                    cert: this.cert
                };
                this.server = https.createServer(certificates, stats);
            }
            else {
                this.server = http.createServer(stats);
            }
        }
        var wssOptions = {
            server: this.server
        };
        if (this.path) {
            wssOptions.path = this.path;
        }
        this.wss = new WebSocket.Server(wssOptions);
        this.wss.on("connection", function (ws, req) {
            var params = url.parse(req.url, true).query;
            var host = _this.host;
            var port = _this.port;
            var pass = _this.pass;
            if (params.pool && _this.dynamicPool) {
                var split = params.pool.split(":");
                host = split[0] || _this.host;
                port = Number(split[1]) || _this.port;
                pass = split[2] || _this.pass;
            }
            var connection = _this.getConnection(host, port);
            var donations = _this.donations.map(function (donation) {
                return new Donation_1.default({
                    address: donation.address,
                    host: donation.host,
                    port: donation.port,
                    pass: donation.pass,
                    percentage: donation.percentage,
                    connection: _this.getConnection(donation.host, donation.port, true)
                });
            });
            var miner = new Miner_1({
                connection: connection,
                ws: ws,
                address: _this.address,
                user: _this.user,
                diff: _this.diff,
                pass: pass,
                donations: donations,
                constant: _this.constant
            });
            miner.on("open", function (data) { return _this.emit("open", data); });
            miner.on("authed", function (data) { return _this.emit("authed", data); });
            miner.on("job", function (data) { return _this.emit("job", data); });
            miner.on("found", function (data) { return _this.emit("found", data); });
            miner.on("accepted", function (data) { return _this.emit("accepted", data); });
            miner.on("close", function (data) { return _this.emit("close", data); });
            miner.on("error", function (data) { return _this.emit("error", data); });
            miner.connect();
        });
        if (!host && !callback) {
            this.server.listen(port);
        }
        else if (!host && callback) {
            this.server.listen(port, callback);
        }
        else if (host && !callback) {
            this.server.listen(port, host);
        }
        else {
            this.server.listen(port, host, callback);
        }
        console.log("listening on port " + port + (isHTTPS ? ", using a secure connection" : ""));
        if (wssOptions.path) {
            console.log("path: " + wssOptions.path);
        }
        if (!this.dynamicPool) {
            console.log("host: " + this.host);
            console.log("port: " + this.port);
            console.log("pass: " + this.pass);
        }
        console.log("constant: " + this.constant);
    };
    Proxy.prototype.getConnection = function (host, port, donation) {
        var _this = this;
        if (donation === void 0) { donation = false; }
        var connectionId = host + ":" + port;
        if (!this.connections[connectionId]) {
            this.connections[connectionId] = [];
        }
        var connections = this.connections[connectionId];
        var availableConnections = connections.filter(function (connection) { return _this.isAvailable(connection); });
        if (availableConnections.length === 0) {
            var connection = new Connection_1({ host: host, port: port, ssl: this.ssl, donation: donation });
            connection.connect();
            connection.on("close", function () {
                console.log("connection closed (" + connectionId + ")");
            });
            connection.on("error", function (error) {
                console.log("connection error (" + connectionId + "):", error.message);
            });
            connections.push(connection);
            return connection;
        }
        return availableConnections.pop();
    };
    Proxy.prototype.isAvailable = function (connection) {
        return connection.miners.length < this.maxMinersPerConnection;
    };
    Proxy.prototype.isEmpty = function (connection) {
        return connection.miners.length === 0 && connection.donations.length === 0;
    };
    Proxy.prototype.getStats = function () {
        var _this = this;
        return Object.keys(this.connections).reduce(function (stats, key) { return ({
            miners: stats.miners.concat(_this.connections[key].reduce(function (miners, connection) { return miners.concat(connection.miners.map(function (miner) { return ({
                id: miner.id,
                login: miner.login,
                hashes: miner.hashes
            }); })); }, [])),
            connections: stats.connections.concat(_this.connections[key].filter(function (connection) { return !connection.donation; }).map(function (connection) { return ({
                id: connection.id,
                host: connection.host,
                port: connection.port,
                miners: connection.miners.length
            }); }))
        }); }, {
            miners: [],
            connections: []
        });
    };
    Proxy.prototype.kill = function () {
        var _this = this;
        Object.keys(this.connections).forEach(function (connectionId) {
            var connections = _this.connections[connectionId];
            connections.forEach(function (connection) {
                connection.kill();
                connection.miners.forEach(function (miner) { return miner.kill(); });
            });
        });
        this.wss.close();
    };

module.exports = Proxy;
