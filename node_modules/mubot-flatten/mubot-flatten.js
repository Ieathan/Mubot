let isBuffer = require('is-buffer')

module.exports = flatten
flatten.flatten = flatten

function flatten (target, opts) {
  opts = opts || {}
  let delimiter = opts.delimiter || '.'
  let maxDepth = opts.maxDepth || 9
  let maxCount = opts.maxCount || 17
  let exclude = opts.exclude || [];
  let filter = opts.filter;
  let output = {}
  let keyCount = {};
  let baseKey;
  function step (object, prev, currentDepth) {
    currentDepth = currentDepth || 1

    let mykeys = Object.keys(object);

    for(let i = 0, len = mykeys.length; i < len; ++i) {
      let key = mykeys[i]
      let value = object[key]
      let isarray = opts.safe && Array.isArray(value)
      let type = Object.prototype.toString.call(value)
      let isbuffer = isBuffer(value)
      let isobject = (
        type === '[object Object]' ||
        type === '[object Array]'
      )
      let newKey = prev
        ? prev + delimiter + key
        : key

      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
        step(value, newKey, currentDepth + 1);
        break;
      }
debugger;
      baseKey = newKey.match(/^(.+?)(?:\.|$)/)[1];
      keyCount[baseKey] ? ++keyCount[baseKey] : keyCount[baseKey] = 1;
      if(keyCount[baseKey] > maxCount || exclude[baseKey] || exclude.includes(baseKey)) {
        break;
      }
      output[newKey] = value
    }
  }

  step(target)
  let final = {};
  if(filter && filter.values) {
     for(let key of Object.values(output).filter(_=>filter.values.test(_))) {
       final[key] = output[key];
     }
  } else if (filter) {
     for(let key of Object.keys(output).filter(_=>filter.test(_))) {
       final[key] = output[key];
     }
  }
  return output
}
