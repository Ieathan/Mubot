# Description:
#   A Marking U Bot.
# 
# Dependencies:
#   bitmarkd must be running
#   bitmark-cli must be in path
#   wallet must be funded
# 
# Configuration:
#   
# 
# Commands:
#   + <times> <user> <reason>        -   Marks the specified user.
#   withdraw <address> <amount>      -   withdraw to address amount.
#   deposit                          -   Display your address.
#   marks [user]                     -   Balance for a user.
# 
# Author:
#   Project Bitmark
# 


# 
# requires

exec = require('child_process').exec;

# init

marks        =  {} # simple key value store or URI / balance for now
symbol       =  'â‚¥'
last         =  'Mubot'
secret       =  process.env.HUBOT_DEPOSIT_SECRET
why_context  =  ''

if process.env.HUBOT_ADAPTER is 'irc'
  adapter = 'irc'
  irc_server = process.env.HUBOT_IRC_SERVER
else if process.env.HUBOT_ADAPTER is 'slack'
  adapter = 'slack'
  slack_team = process.env.HUBOT_SLACK_TEAM
else if process.env.HUBOT_ADAPTER is 'shell'
  adapter = 'shell'
else
  adapter = 'discord' or throw new Error('HUBOT_ADAPTER env variable is required') 


# functions
to_URI = ( id ) ->
  if id.indexOf(':') != -1
    id
  else if adapter is 'irc'
    'irc://' + id.toLowerCase() + '@' + irc_server + '/'
  else if adapter is 'slack'
    'https://' + slack_team + '.slack.com/team/' + id.toLowerCase() + '#this'
  else if adapter is 'shell'
    'urn:shell:' + id.toLowerCase()
  else
     id

from_URI = ( URI ) ->
  if URI.indexOf('irc://') is 0 and adapter is 'irc'
    URI.split(":")[1].substring(2).split('@')[0]
  else if URI.indexOf('https://' + slack_team + '.slack.com/team/') is 0 and URI.indexOf('#this') != -1 and adapter is 'slack'
    URI.split(":")[1].substring(2).split('/')[2].split('#')[0]
  else
    URI

#   Decommisioned
#   deposit  <user> <amount> <secret> - deposit amount using shared secret
deposit_marks = (msg, URI, amount, robot) ->
  robot.brain.data.marks[URI] ?= 0
  robot.brain.data.marks[URI] += parseFloat(amount)
  msg.send amount + symbol + ' to ' + from_URI(URI) + '.'

transfer_marks = (msg, URI, amount, robot) ->
  if !why_context?
    why_context = "N/A"
  if robot.brain.data.marks[to_URI(msg.message.user.id)] >= parseFloat(amount)
    robot.brain.data.marks[URI] ?= 0
    robot.brain.data.marks[URI] += parseFloat(amount)
    robot.brain.data.marks[to_URI(msg.message.user.id)] -= parseFloat(amount)
    msg.send msg.message.user.name + ' has marked ' + robot.brain.data.users[URI].name + ' ' + amount + symbol + '. ( ' + why_context + ' )'
  else
    msg.send 'Sorry, but you dont have enough marks. Try the deposit command or get marked more.'


withdraw_marks = (msg, address, amount, robot) ->
  if robot.brain.data.marks[to_URI(msg.message.user.name)] >= parseFloat(amount)
    command = 'bitmark-cli sendtoaddress ' + address + ' ' + ( parseFloat(amount) / 1000.0 )
    console.log(command)
    exec command, (error, stdout, stderr) ->
      console.log(error)
      console.log(stdout)
      console.log(stderr)
      robot.brain.data.marks[to_URI(msg.message.user.name)] -= parseFloat(amount)
      msg.send stdout
  else
    msg.send 'Sorry, you have not been marked that many times yet.'


# MAIN

module.exports = (robot) ->
  robot.brain.on 'loaded', ->
    robot.brain.data.marks ?= {}
    marks = robot.brain.data.marks or {}
    robot.brain.resetSaveInterval(1)
    robot.brain.data.marks['183771581829480448'] ?= 12000

  robot.hear /^\+(\d+)\s+<@?!?(\d+)>\s*(.*)?$/i, (msg) ->
    if msg.match[2] is '329612596397342721'
      msg.send "Sorry but I am currently unmarkable."
      return
    if msg.match[2] is msg.message.user.id
      msg.send "Sorry but you cannot mark yourself."
      return
    why_context = msg.match[3]
    plus = msg.match[1]
    if plus <= 25
      transfer_marks(msg, to_URI(msg.match[2]), plus, robot)
    else
      msg.send 'Max is +25'

#  REMOVED TO AVOID BLOAT
#  robot.hear /^\+(\d+)$/i, (msg) ->
#    plus = msg.match[1]
#    transfer_marks(msg, to_URI(last), plus, robot)
  
  # WITHDRAW
  robot.hear /withdraw\s+([\w\S]+)\s+(\d+)\s*$/i, (msg) ->
    destination = msg.match[1]
    withdraw_marks(msg, destination, msg.match[2], robot)
    
  # BALANCE
  robot.hear /^marks\s+<@?!?(\d+)>$/i, (msg) ->
    if robot.brain.data.users[msg.match[1]]
      URI = to_URI(msg.match[1])
      robot.brain.data.marks[URI] ?= 0
      msg.send robot.brain.data.users[msg.match[1]].name + ' has ' + robot.brain.data.marks[URI] + symbol + '.'
    else
      msg.send "Sorry, I can't find that user."

  robot.hear /^marks\s*$/i, (msg) ->
    URI = to_URI(msg.message.user.id)
    robot.brain.data.marks[URI] ?= 0
    msg.send 'You have ' + robot.brain.data.marks[URI] + symbol + '.'

  # WEB 
  robot.router.get "/#{robot.name}/marks", (req, res) ->
    res.end robot.brain.data.marks

#  REMOVED TO AVOID BLOAT
#  # LOG / REMEMBER LAST USER
#  robot.hear /.*/i, (msg) ->
#    last = msg.message.user.id
