# Description:
#   Add programmable interface to mubot.  Allow to run a mubot command
#   whenever something came up in the conversation. Optionally, multiple 
#   actions can be specified, with or without ordering.
#
# Dependencies:
#   None
#
# Configuration:
#   None
#
# Commands:
#   mubot when you hear <pattern> do <something mubot does> - Setup a ear dropping event
#   mubot when you hear <pattern> do 1|<something mubot does>; 2|<some.... - Set up ear dropping with multiple actions and ordering
#   mubot stop ear dropping - Stop all ear dropping
#   mubot stop ear dropping on <pattern> - Remove a particular ear dropping event
#   mubot show ear dropping - Show what mubot is ear dropping on
#
# Author:
#   garylin

TextMessage = require('mubot').TextMessage

class EarDropping
  constructor: (@bot) ->
    @cache = []
    @bot.brain.on 'loaded', =>
      if @bot.brain.data.eardropping
        @cache = @bot.brain.data.eardropping
  add: (pattern, action, order) ->
    task = {key: pattern, task: action, order: order}
    @cache.push task
    @bot.brain.data.eardropping = @cache
  all: -> @cache
  deleteByPattern: (pattern) ->
    @cache = @cache.filter (n) -> n.key != pattern
    @bot.brain.data.eardropping = @cache
  deleteAll: () ->
    @cache = []
    @bot.brain.data.eardropping = @cache

module.exports = (bot) ->
  earDropping = new EarDropping bot

  bot.respond /when you hear (.+?) do (.+?)$/i, (msg) ->
    key = msg.match[1]
    for task_raw in msg.match[2].split ";"
      task_split = task_raw.split "|"
      # If it's a single task, don't add an "order" property
      if not task_split[1]
        earDropping.add(key, task_split[0])
      else
        earDropping.add(key, task_split[1], task_split[0])
    msg.send "I am now ear dropping for #{key}. Hehe."

  bot.respond /stop ear *dropping$/i, (msg) ->
    earDropping.deleteAll()
    msg.send 'Okay, fine. :( I will keep my ears shut.'

  bot.respond /stop ear *dropping (for|on) (.+?)$/i, (msg) ->
    pattern = msg.match[2]
    earDropping.deleteByPattern(pattern)
    msg.send "Okay, I will ignore #{pattern}"

  bot.respond /show ear *dropping/i, (msg) ->
    response = "\n"
    for task in earDropping.all()
      response += "#{task.key} -> #{task.task}\n"
    msg.send response

  bot.hear /(.+)/i, (msg) ->
    botHeard = msg.match[1]

    tasks = earDropping.all()
    tasks.sort (a,b) ->
      return if a.order >= b.order then 1 else -1

    tasksToRun = []
    for task in tasks
      if new RegExp(task.key, "i").test(botHeard)
        tasksToRun.push task

    tasksToRun.sort (a,b) ->
      return if a.order >= b.order then 1 else -1

    for task in tasksToRun
      if (bot.name != msg.message.user.name && !(new RegExp("^#{bot.name}", "i").test(botHeard)))
        bot.receive new TextMessage(msg.message.user, "#{bot.name}: #{task.task}")
