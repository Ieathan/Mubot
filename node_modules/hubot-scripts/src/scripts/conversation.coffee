# Description:
#   Extends bot adding conversation features
#
# Dependencies:
#   None
#
# Configuration:
#   None
#
# Commands:
#   None
#
# Author:
#   pescuma

module.exports = (bot) ->
  bot.eatListeners = {}

  # Public: Adds a Listener that receives the next message from the user and av
  # further processing of it.
  #
  # user     - The user name.
  # callback - A Function that is called with a Response object. msg.match[1] w
  #            contain the message text without the bot name
  #
  # Returns nothing.
  bot.eatOneResponse = (user, callback) ->
    bot.eatListeners[user.id] = new Listener(bot, callback)

  # Change default receive command, addind processing of eatListeners
  bot.origReceive = bot.receive
  bot.receive = (message) ->
    if message.user? and bot.eatListeners[message.user.id]?
      lst = bot.eatListeners[message.user.id]
      delete bot.eatListeners[message.user.id]

      if lst.call message
        return

      # Put back to process next message
      bot.eatListeners[message.user.id] = lst

    bot.origReceive(message)

  # Public: Waits for the next message from the current user.
  #
  # callback - Called with the user response
  #
  # Returns nothing.
  bot.Response.prototype.waitResponse = (callback) ->
    bot.eatOneResponse this.message.user, callback

class Listener
  constructor: (@bot, @callback) ->
    if bot.enableSlash
      @regex = new RegExp("^(?:\/|#{bot.name}:?)\\s*(.*?)\\s*$", 'i')
    else
      @regex = new RegExp("^#{bot.name}:?\\s*(.*?)\\s*$", 'i')

    @matcher = (message) =>
      if message.text?
        message.text.match @regex

  call: (message) =>
    if match = @matcher message
      @callback new @bot.Response(@bot, message, match)
      return true
    else
      return false
