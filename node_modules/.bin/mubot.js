
(function() {
  var Fs, OptParse, Options, Parser, Path, Switches, loadScripts, bot, Mubot;

  Mubot = require('mubot');

  Fs = require('fs');

  OptParse = require('optparse');

  Path = require('path');

  Switches = [["-a", "--adapter ADAPTER", "The Adapter to use"], ["-c", "--create PATH", "Create a deployable mubot"], ["-d", "--disable-httpd", "Disable the HTTP server"], ["-h", "--help", "Display the help information"], ["-l", "--alias ALIAS", "Enable replacing the bot's name with alias"], ["-n", "--name NAME", "The name of the bot in chat"], ["-r", "--require PATH", "Alternative scripts path"], ["-t", "--config-check", "Test mubot's config to make sure it won't fail at startup"], ["-v", "--version", "Displays the version of mubot installed"]];

  Options = {
    adapter: process.env.MUBOT_ADAPTER || "shell",
    alias: process.env.MUBOT_ALIAS || false,
    create: process.env.MUBOT_CREATE || false,
    enableHttpd: process.env.MUBOT_HTTPD || true,
    scripts: process.env.MUBOT_SCRIPTS || [],
    name: process.env.MUBOT_NAME || "Mubot",
    path: process.env.MUBOT_PATH || ".",
    configCheck: false
  };

  Parser = new OptParse.OptionParser(Switches);

  Parser.banner = "Usage mubot [options]";

  Parser.on("adapter", function(opt, value) {
    return Options.adapter = value;
  });

  Parser.on("create", function(opt, value) {
    Options.path = value;
    return Options.create = true;
  });

  Parser.on("disable-httpd", function(opt) {
    return Options.enableHttpd = false;
  });

  Parser.on("help", function(opt, value) {
    console.log(Parser.toString());
    return process.exit(0);
  });

  Parser.on("alias", function(opt, value) {
    value || (value = '/');
    return Options.alias = value;
  });

  Parser.on("name", function(opt, value) {
    return Options.name = value;
  });

  Parser.on("require", function(opt, value) {
    return Options.scripts.push(value);
  });

  Parser.on("config-check", function(opt) {
    return Options.configCheck = true;
  });

  Parser.on("version", function(opt, value) {
    return Options.version = true;
  });

  Parser.on(function(opt, value) {
    return console.warn("Unknown option: " + opt);
  });

  Parser.parse(process.argv);

  if (process.platform !== "win32") {
    process.on('SIGTERM', function() {
      return process.exit(0);
    });
  }

  if (Options.create) {
    console.error("'mubot --create' is deprecated. Use the yeoman generator instead:");
    console.error("    npm install -g yo generator-mubot");
    console.error("    mkdir -p " + Options.path);
    console.error("    cd " + Options.path);
    console.error("    yo mubot");
    process.exit(1);
  } else {
    bot = Mubot.loadBot(void 0, Options.adapter, Options.enableHttpd, Options.name, Options.alias);
    if (Options.version) {
      console.log(bot.version);
      process.exit(0);
    }
    loadScripts = function() {
      var data, err, externalScripts, mubotScripts, mubotScriptsReplacements, mubotScriptsWarning, i, j, k, len, len1, len2, path, ref, replacement, replacements, replacementsData, results, script, scripts, scriptsPath, scriptsWithoutReplacements;
      scriptsPath = Path.resolve(".", "scripts");
      bot.load(scriptsPath);
      scriptsPath = Path.resolve(".", "src", "scripts");
      bot.load(scriptsPath);
      mubotScripts = Path.resolve(".", "mubot-scripts.json");
      if (Fs.existsSync(mubotScripts)) {
        data = Fs.readFileSync(mubotScripts);
        if (data.length > 0) {
          try {
            scripts = JSON.parse(data);
            scriptsPath = Path.resolve("node_modules", "mubot-scripts", "src", "scripts");
            bot.loadMubotScripts(scriptsPath, scripts);
          } catch (error) {
            err = error;
            bot.logger.error("Error parsing JSON data from mubot-scripts.json: " + err);
            process.exit(1);
          }
          mubotScriptsReplacements = Path.resolve("node_modules", "mubot-scripts", "replacements.json");
          if (Fs.existsSync(mubotScriptsReplacements)) {
            mubotScriptsWarning += "The following scripts have known replacements. Follow the link for installation instructions, then remove it from mubot-scripts.json:\n";
            replacementsData = Fs.readFileSync(mubotScriptsReplacements);
            replacements = JSON.parse(replacementsData);
            scriptsWithoutReplacements = [];
            for (i = 0, len = scripts.length; i < len; i++) {
              script = scripts[i];
              replacement = replacements[script];
              if (replacement) {
                mubotScriptsWarning += "* " + script + ": " + replacement + "\n";
              } else {
                scriptsWithoutReplacements.push(script);
              }
            }
            mubotScriptsWarning += "\n";
            if (scriptsWithoutReplacements.length > 0) {
              mubotScriptsWarning += "The following scripts don't have (known) replacements. You can try searching https://www.npmjs.com/ or http://github.com/search or your favorite search engine. You can copy the script into your local scripts directory, or consider creating a new package to maintain yourself. If you find a replacement or create a package yourself, please post on https://github.com/github/mubot-scripts/issues/1641:\n";
              for (j = 0, len1 = scriptsWithoutReplacements.length; j < len1; j++) {
                script = scriptsWithoutReplacements[j];
                mubotScriptsWarning += "* " + script + "\n";
              }
              mubotScriptsWarning += "\nYou an also try updating mubot-scripts to get the latest list of replacements: npm install --save mubot-scripts@latest";
            }
          } else {
            mubotScriptsWarning += "To get a list of recommended replacements, update your mubot-scripts: npm install --save mubot-scripts@latest";
          }
        }
        bot.logger.warning(mubotScriptsWarning);
      }
      externalScripts = Path.resolve(".", "external-scripts.json");
      if (Fs.existsSync(externalScripts)) {
        Fs.readFile(externalScripts, function(err, data) {
          if (data.length > 0) {
            try {
              scripts = JSON.parse(data);
            } catch (error) {
              err = error;
              console.error("Error parsing JSON data from external-scripts.json: " + err);
              process.exit(1);
            }
            return bot.loadExternalScripts(scripts);
          }
        });
      }
      ref = Options.scripts;
      results = [];
      for (k = 0, len2 = ref.length; k < len2; k++) {
        path = ref[k];
        if (path[0] === '/') {
          scriptsPath = path;
        } else {
          scriptsPath = Path.resolve(".", path);
        }
        results.push(bot.load(scriptsPath));
      }
      return results;
    };
    if (Options.configCheck) {
      loadScripts();
      console.log("OK");
      process.exit(0);
    }
    bot.adapter.once('connected', loadScripts);
    bot.run();
  }

}).call(this);

