(function() {
  const indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
  const hasProp = {}.hasOwnProperty;

  const Fs = require('fs');
  const Log = require('log');
  const Path = require('path');
  const HttpClient = require('scoped-http-client');
  const { EventEmitter } = require('events');
  const async = require('async');
  const User = require('./user');
  const Brain = require('./brain');
  const Response = require('./response');
  const { Listener, TextListener } = require('./listener');
  const { EnterMessage, LeaveMessage, TopicMessage, CatchAllMessage } = require('./message');
  const Middleware = require('./middleware');

  const DEFAULT_ADAPTERS = ['campfire', 'shell'];
  const DOC_SECTIONS = ['description', 'dependencies', 'configuration', 'commands', 'notes', 'author', 'authors', 'examples', 'tags', 'urls'];
  //Robot = (function() {
    function Robot(adapterPath, adapter, httpd, name, alias) {
      if (!name) name = 'Mubot';
      if (!alias) alias = false;
      if (!this.adapterPath) this.adapterPath = Path.join(__dirname, "adapters");
      this.name = name;
      this.events = new EventEmitter;
      this.brain = new Brain(this);
      this.alias = alias;
      this.adapter = null;
      this.io = null;
      this.Response = Response;
      this.commands = [];
      this.listeners = [];
      this.middleware = {
        listener: new Middleware(this),
        response: new Middleware(this),
        receive: new Middleware(this)
      };
      this.logger = new Log(process.env.HUBOT_LOG_LEVEL || 'info');
      this.pingIntervalId = null;
      this.globalHttpOptions = {};
      this.parseVersion();
      if (httpd) this.setupExpress(); else this.setupNullRouter();
      this.loadAdapter(adapter);
      this.adapterName = adapter;
      this.errorHandlers = [];

      this.on('error', (err, res) => this.invokeErrorHandlers(err, res))
      this.onUncaughtException = err => this.emit('error', err)
      process.on('uncaughtException', this.onUncaughtException)
    }

    Robot.prototype.listen = function(matcher, options, callback) {
      this.listeners.push(new Listener(this, matcher, options, callback));
    };

    Robot.prototype.hear = function(regex, options, callback) {
      this.listeners.push(new TextListener(this, regex, options, callback));
    };

    Robot.prototype.respond = function(regex, options, callback) {

      this.hear(this.respondPattern(regex), options, callback);
    };
    Robot.prototype.respondPattern = function(regex) {
      var alias, modifiers, name, newRegex, pattern, reArray, anchored;
      reArray = regex.toString().split('/');
      reArray.shift();
      modifiers = reArray.pop();
      pattern = reArray[0];
      if (/^\^/.test(pattern)) {
        this.logger.warning("The ^ Anchor doesn't work with respond, use 'hear': " + regex.toString())
      }
      name = this.name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
      if (this.alias) {
        alias = this.alias.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        newRegex = new RegExp("^\\s*[@]?(?:" + alias + "[:,]?|" + name + "[:,]?)\\s*(?:" + pattern + ")", modifiers);
      } else {
        newRegex = new RegExp("^\\s*[@]?" + name + "[:,]?\\s*(?:" + pattern + ")", modifiers);
      }
      return newRegex;
    };

    Robot.prototype.enter = function(options, callback) {
      this.listen(msg => msg instanceof EnterMessage, options, callback);
    };

    Robot.prototype.leave = function(options, callback) {
      this.listen(msg => msg instanceof LeaveMessage, options, callback);
    };

    Robot.prototype.topic = function(options, callback) {
      this.listen(msg => msg instanceof Message.TopicMessage, options, callback);
    };

    Robot.prototype.error = function(callback) {
      this.errorHandlers.push(callback);
    };

    Robot.prototype.invokeErrorHandlers = function(err, res) {
      var ref, results;
      this.logger.error(err.stack);
      ref = this.errorHandlers;
      for (let i = 0, len = ref.length; i < len; i++) {
        let errorHandler = ref[i];
        try {
          errorHandler(err, res);
        } catch (errErr) {
          this.logger.error("while invoking error handler: " + errErr + "\n" + errErr.stack);
        }
      }
    };

    Robot.prototype.catchAll = function(options, callback) {
      if (!callback) {
        callback = options;
        options = {};
      }
      this.listen(msg => msg instanceof CatchAllMessage, options, msg => {
        msg.message = msg.message.message;
        callback(msg);
      })
    };
    Robot.prototype.listenerMiddleware = function(middleware) {
      this.middleware.listener.register(middleware);
    };

    Robot.prototype.responseMiddleware = function(middleware) {
      this.middleware.response.register(middleware);
    };

    Robot.prototype.receiveMiddleware = function(middleware) {
      this.middleware.receive.register(middleware);
    };

    Robot.prototype.receive = function(message, cb) {
     this.middleware.receive.execute({ response: new Response(this, message) }, this.processListeners.bind(this), cb);
    };

    Robot.prototype.processListeners = function(context, done) {
      var anyListenersExecuted = false;
      async.detectSeries(this.listeners, (listener, cb) => {
        var err;
        try {
          listener.call(context.response.message, this.middleware.listener, listenerExecuted => {
            anyListenersExecuted = anyListenersExecuted || listenerExecuted;
            //Middleware.ticker(() => cb(context.response.message.done));
            process.nextTick(() => cb(context.response.message.done));
          });
        } catch (err) {
          this.emit('error', err, new this.Response(this, context.response.message, []));
          cb(false);
        }
      }, () => { //_ => {
        if (!(context.response.message instanceof CatchAllMessage) && !anyListenersExecuted) {
          this.logger.debug('No listeners executed; falling back to catch-all');
          this.receive(new CatchAllMessage(context.response.message), done);
        } else {
          if (done) process.nextTick(done);
        }
      })
    };

    Robot.prototype.loadFile = function(path, file) {
      var ext, full;
      ext = Path.extname(file);
      full = Path.join(path, Path.basename(file, ext));
      if (require.cache[require.resolve(full)]) {
        try {
          let cacheobj = require.resolve(full);
          this.logger.debug("require cache for " + cacheobj + " invalidated.");
          delete require.cache[cacheobj];
        } catch (err) {
          this.logger.error("Unable to invalidate " + cacheobj + ": " + err.stack);
        }
      }
      if (require.extensions[ext]) {
        try {
          let script = require(full);
          if (typeof script === 'function') {
            script(this);
            this.parseHelp(Path.join(path, file));
          } else {
            this.logger.warning("Expected " + full + " to assign a function to module.exports, got " + (typeof script));
          }
        } catch (err) {
          this.logger.error("Unable to load " + full + ": " + err.stack);
          return process.exit(1);
        }
      }
    };
    Robot.prototype.load = function(path) {
      this.logger.debug("Loading scripts from " + path);
      if (Fs.existsSync(path)) {
        let ref = Fs.readdirSync(path).sort();
        let results = [];
        for (let i = 0, len = ref.length; i < len; i++) {
          let file = ref[i];
          results.push(this.loadFile(path, file));
        }
        return results;
      }
    };

    Robot.prototype.loadHubotScripts = function(path, scripts) {
      this.logger.debug("Loading hubot-scripts from " + path + ".");
      for (let i = 0, len = scripts.length; i < len; i++) {
        this.loadFile(path, scripts[i]);
      }
    };

    Robot.prototype.loadExternalScripts = function(packages) {
      this.logger.debug("Loading external-scripts from npm packages");
      try {
        if (packages instanceof Array) {
          for (let i = 0, len = packages.length; i < len; i++) {
            pkg = packages[i];
            require(pkg)(this);
          }
        } else {
          for (let pkg in packages) {
            require(pkg)(this, packages[pkg]);
          }
        }
      }
      catch (err) {
        this.logger.error("Error loading scripts from npm package - " + err.stack);
        process.exit(1);
      }
    };

    Robot.prototype.setupExpress = function() {
      var secret, address, parseurl, session, app, basicAuth, bodyParser, cookieParser, express, fs, http, https, logger, multipart, options, pass, port, stat, user;
      user          = process.env.EXPRESS_USER;
      pass          = process.env.EXPRESS_PASSWORD;
      stat          = process.env.EXPRESS_STATIC;
      secret        = process.env.EXPRESS_SECRET || 'loyalty is to be placed, and unplaced, but never replaced';
      port          = process.env.EXPRESS_PORT || process.env.PORT || 8080;
      sPort         = process.env.EXPRESS_SECURE_PORT || process.env.SECURE_PORT || 4343;
      address       = process.env.EXPRESS_BIND_ADDRESS || process.env.BIND_ADDRESS || '0.0.0.0';
      express       = require('express');
      multipart     = require('connect-multiparty');
      bodyParser    = require('body-parser');
      basicAuth     = require('basic-auth-connect');
      cookieParser  = require('cookie-parser');
      logger        = require('morgan');
      app           = express();
      parseurl      = require('parseurl')
      // To replace custom cookie login:
      //session       = require('express-session')

      //app.use(session({
      //  secret: secret,
      //  resave: false,
      //  saveUninitialized: true
      //}))

      //app.use((req, res, next) => {
      //  // Example to log each session viewcount per path.
      //  //var views, path;
      //  res.setHeader("X-Powered-By", "Mubotv0.1.0 / " + this.name);
      //  //views = req.session.views
      //  //if (!views) views = req.session.views = {}
      //  //path = parseurl(req).pathname
      //  //views[path] = (views[path] || 0) + 1
      //  next()
      //})

      // Debugging
      //app.get('/debug', function (req, res, next) {
      //  res.writeHead(200, { 'Content-Type': 'text/plain' });
      //  //res.write('you viewed this page ' + req.session.views['/debug'] + ' times.\n')
      //  res.write('Echo service: ' + req.url + '\n' + JSON.stringify(req.headers, true, 2));
      //  req.pipe(res);
      //  res.end();
      //})
      if(process.env.HUBOT_LOG_LEVEL) app.use(logger("dev"));
      if (user && pass)               app.use("/admin", basicAuth(user, pass));
      if (stat)                       app.use(express.static(stat));
      app.use(bodyParser.json         ({ extended: true }));
      app.use(bodyParser.urlencoded   ({ extended: true }));
      app.use(express.query())
      ;
      app.use(cookieParser())
      ;
      app.use(function(req, res, next) {
        // Allow *.leathan.xyz:* and *.leat.io:* subdomains.
        if(/(^|\.)leat(han\.xyz|\.io)$/i.test(req.hostname)) {
          res.header("Access-Control-Allow-Origin", '*')
          ;
          // res.header("Access-Control-Allow-Origin", "*")
          // res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  				next()
          ;
        }
      })
      ;
      https   = require('https');
      http    = require('http');
      options = {
        key: Fs.readFileSync (Path.join(__dirname, '../../hubot-server/credentials/privkey.pem')),
        cert: Fs.readFileSync(Path.join(__dirname, '../../hubot-server/credentials/fullchain.pem')),
        ca: Fs.readFileSync  (Path.join(__dirname, '../../hubot-server/credentials/chain.pem'))
      };
      this.server = https.createServer(options, app).listen(sPort, function() {
        return console.log('listening on port ' + sPort + '.');
      }).on('error', e => {
        if(e.code == "EADDRINUSE") console.log("cant listen on port " + sPort + ", address is use.")
      })

      this.io = require('socket.io')(this.server) /*, {
        origins: "leat.io:* leathan.xyz:*",
        path: '/'
      });*/

      http.createServer((req, res) => {
        res.writeHead(301, { 'Location': 'https://' + req.headers.host + req.url });
        return res.end();
      }).listen(port, function() {
        return console.log('listening on port ' + port + '.');
      }).on('error', e => {
        if(e.code == "EADDRINUSE") console.log("cant listen on port " + port + ", address is use.")
      })
      return this.router = app;
    };

    Robot.prototype.setupNullRouter = function() {
      var msg = "A script has tried registering an HTTP route while the server is disabled with --disabled-httpd.";
      return this.router = {
        get: () => this.logger.warning(msg),
        post: () => this.logger.warning(msg),
        put: () => this.logger.warning(msg),
        delete: () => this.logger.warning(msg)
      };
    };

    Robot.prototype.loadAdapter = function(adapter) {
      var err, path;
      this.logger.debug("Loading adapter " + adapter);
      try {
        path = DEFAULT_ADAPTERS.includes(adapter) ? this.adapterPath + "/" + adapter : "hubot-" + adapter;
        this.adapter = require(path).use(this);
      } catch (err) {
        this.logger.error("Cannot load adapter " + adapter + " - " + err);
        process.exit(1)
        ;
      }
    }
    ;
    Robot.prototype.helpCommands = function() {
      return this.commands.sort();
    }
    ;
    Robot.prototype.parseHelp = function(path) {
      var body, cleanedLine, currentSection, line, nextSection, lines, results, scriptDocumentation, scriptName;
      this.logger.debug("Parsing help for " + path);
      scriptName = Path.basename(path).replace(/\.(coffee|js)$/, '');
      scriptDocumentation = {};
      body = Fs.readFileSync(path, 'utf-8');
      currentSection = null;
      lines = body.split("\n");
      for (let i = 0, len = lines.length; i < len; i++) {
        line = lines[i];
        if(!/(#|\/\/)/.test(line)) break;
        cleanedLine = line.replace(/^(#|\/\/)\s?/, "").trim();
        if (cleanedLine.length === 0) continue;
        if (cleanedLine.toLowerCase() === 'none') continue;
        nextSection = cleanedLine.toLowerCase().replace(':', '');
        if (DOC_SECTIONS.includes(nextSection)) {
          currentSection = nextSection;
          scriptDocumentation[currentSection] = [];
        } else if (currentSection) {
          scriptDocumentation[currentSection].push(cleanedLine.trim());
          if (currentSection === 'commands') {
            this.commands.push(cleanedLine.trim());
          }
        }
      }
      if (currentSection === null) {
        this.logger.info(path + " is using deprecated documentation syntax");
        scriptDocumentation.commands = [];
        lines = body.split("\n");
        results = [];
        for (let i = 0, l = lines.length; i < l; i++) {
          line = lines[i];
          if(!/(#|\/\/)/.test(line)) break;
          if(!/-/.test(line)) continue;
          cleanedLine = line.slice(2, line.length).replace(/^(hubot|mubot)/i, this.name).trim();
          scriptDocumentation.commands.push(cleanedLine);
          results.push(this.commands.push(cleanedLine));
        }
        return results;
      }
    };

    Robot.prototype.send = function(envelope) {
      const strings = [].slice.call(arguments, 1)
      this.adapter.send.apply(this, [envelope].concat(strings))
    };

    Robot.prototype.reply = function(envelope) {
      const strings = [].slice.call(arguments, 1)
      this.adapter.reply.apply(this, [envelope].concat(strings))
    };

    Robot.prototype.messageRoom = function(room) {
      const strings = [].slice.call(arguments, 1)
      const envelope = { room }
      this.adapter.send.apply(this.adapter, [envelope].concat(strings))
    };

    Robot.prototype.on = function(event) {
      const args = [].slice.call(arguments, 1)
      this.events.on.apply(this, [event].concat(args))
    };

    Robot.prototype.emit = function(event) {
      const args = [].slice.call(arguments, 1)
      this.events.emit.apply(this, [event].concat(args))
    };

    Robot.prototype.run = function() {
      this.emit("running");
      this.adapter.run();
    };

    Robot.prototype.shutdown = function() {
      if (this.pingIntervalId) clearInterval(this.pingIntervalId);
      process.removeListener('uncaughtException', this.onUncaughtException);
      this.adapter.close();
      this.brain.close();
    };

    Robot.prototype.parseVersion = function() {
      const pkg = require(Path.join(__dirname, '..', 'package.json'));
      return this.version = pkg.version;
    };

    Robot.prototype.http = function(url, options) {
      return HttpClient.create(url, this.extend({}, this.globalHttpOptions, options)).header('User-Agent', "Mubot/" + this.version);
    };

    Robot.prototype.extend = function(obj) {
      const sources = [].slice.call(arguments, 1);
      for (let i = 0, l = sources.length; i < l; i++) {
        let source = sources[i];
        for (let key in source) {
          if (!hasProp.call(source, key)) continue;
          obj[key] = source[key];
        }
      }
      return obj;
    };
 //   return Robot;

 // })();

  module.exports = Robot;

}).call(this);
