// Generated by CoffeeScript 1.12.6
(function() {
  var Brain, CatchAllMessage, EnterMessage, EventEmitter, Fs, HUBOT_DEFAULT_ADAPTERS, HUBOT_DOCUMENTATION_SECTIONS, HttpClient, LeaveMessage, Listener, Log, Middleware, Path, Response, Robot, TextListener, TopicMessage, User, async, ref, ref1,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  Fs = require('fs');
  Log = require('log');
  Path = require('path');
  HttpClient = require('scoped-http-client');
  EventEmitter = require('events').EventEmitter;
  async = require('async');
  User = require('./user');
  Brain = require('./brain');
  Response = require('./response');
  ref = require('./listener'), Listener = ref.Listener, TextListener = ref.TextListener;
  ref1 = require('./message'), EnterMessage = ref1.EnterMessage, LeaveMessage = ref1.LeaveMessage, TopicMessage = ref1.TopicMessage, CatchAllMessage = ref1.CatchAllMessage;
  Middleware = require('./middleware');

  HUBOT_DEFAULT_ADAPTERS = ['campfire', 'shell'];

  HUBOT_DOCUMENTATION_SECTIONS = ['description', 'dependencies', 'configuration', 'commands', 'notes', 'author', 'authors', 'examples', 'tags', 'urls'];

  Robot = (function() {
    function Robot(adapterPath, adapter, httpd, name, alias) {
      if (name == null) {
        name = 'Hubot';
      } // name our hubot
      if (alias == null) {
        alias = false;
      } // set alias for scanning
      if (this.adapterPath == null) {
        this.adapterPath = Path.join(__dirname, "adapters");
      } // if adapter is not specified use the default
      this.name = name;
      this.events = new EventEmitter;
      this.brain = new Brain(this);
      this.alias = alias;
      this.adapter = null;
      this.Response = Response;
      this.commands = [];
      this.listeners = [];
      this.middleware = {
        listener: new Middleware(this),
        response: new Middleware(this),
        receive: new Middleware(this)
      };
      this.logger = new Log(process.env.HUBOT_LOG_LEVEL || 'info');
      this.pingIntervalId = null;
      this.globalHttpOptions = {};
      this.parseVersion();
      if (httpd) {
        this.setupExpress();
      } else {
        this.setupNullRouter();
      }
      this.loadAdapter(adapter);
      this.adapterName = adapter;
      this.errorHandlers = [];
      this.on('error', (function(_this) {
        return function(err, res) {
          return _this.invokeErrorHandlers(err, res);
        };
      })(this));
      this.onUncaughtException = (function(_this) {
        return function(err) {
          return _this.emit('error', err);
        };
      })(this);
      process.on('uncaughtException', this.onUncaughtException);
    }

    Robot.prototype.listen = function(matcher, options, callback) {
      return this.listeners.push(new Listener(this, matcher, options, callback));
    };

    Robot.prototype.hear = function(regex, options, callback) {
      return this.listeners.push(new TextListener(this, regex, options, callback));
    };

    Robot.prototype.respond = function(regex, options, callback) {
      return this.hear(this.respondPattern(regex), options, callback);
    };

    Robot.prototype.respondPattern = function(regex) {
      var a, alias, b, modifiers, name, newRegex, pattern, re, ref2;
      re = regex.toString().split('/');
      re.shift();
      modifiers = re.pop();
      if (re[0] && re[0][0] === '^') {
        this.logger.warning("Anchors don't work well with respond, perhaps you want to use 'hear'");
        this.logger.warning("The regex in question was " + (regex.toString()));
      }
      pattern = re.join('/');
      name = this.name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
      if (this.alias) {
        alias = this.alias.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        ref2 = name.length > alias.length ? [name, alias] : [alias, name], a = ref2[0], b = ref2[1];
        newRegex = new RegExp("^\\s*[@]?(?:" + a + "[:,]?|" + b + "[:,]?)\\s*(?:" + pattern + ")", modifiers);
      } else {
        newRegex = new RegExp("^\\s*[@]?" + name + "[:,]?\\s*(?:" + pattern + ")", modifiers);
      }
      return newRegex;
    };

    Robot.prototype.enter = function(options, callback) {
      return this.listen((function(msg) {
        return msg instanceof EnterMessage;
      }), options, callback);
    };

    Robot.prototype.leave = function(options, callback) {
      return this.listen((function(msg) {
        return msg instanceof LeaveMessage;
      }), options, callback);
    };

    Robot.prototype.topic = function(options, callback) {
      return this.listen((function(msg) {
        return msg instanceof TopicMessage;
      }), options, callback);
    };

    Robot.prototype.error = function(callback) {
      return this.errorHandlers.push(callback);
    };

    Robot.prototype.invokeErrorHandlers = function(err, res) {
      var errErr, errorHandler, i, len, ref2, results;
      this.logger.error(err.stack);
      ref2 = this.errorHandlers;
      results = [];
      for (i = 0, len = ref2.length; i < len; i++) {
        errorHandler = ref2[i];
        try {
          results.push(errorHandler(err, res));
        } catch (error1) {
          errErr = error1;
          results.push(this.logger.error("while invoking error handler: " + errErr + "\n" + errErr.stack));
        }
      }
      return results;
    };

    Robot.prototype.catchAll = function(options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      return this.listen((function(msg) {
        return msg instanceof CatchAllMessage;
      }), options, (function(msg) {
        msg.message = msg.message.message;
        return callback(msg);
      }));
    };

    Robot.prototype.listenerMiddleware = function(middleware) {
      this.middleware.listener.register(middleware);
      return void 0;
    };

    Robot.prototype.responseMiddleware = function(middleware) {
      this.middleware.response.register(middleware);
      return void 0;
    };

    Robot.prototype.receiveMiddleware = function(middleware) {
      this.middleware.receive.register(middleware);
      return void 0;
    };

    Robot.prototype.receive = function(message, cb) {
      return this.middleware.receive.execute({
        response: new Response(this, message)
      }, this.processListeners.bind(this), cb);
    };

    Robot.prototype.processListeners = function(context, done) {
      var anyListenersExecuted;
      anyListenersExecuted = false;
      async.detectSeries(this.listeners, (function(_this) {
        return function(listener, cb) {
          var err;
          try {
            return listener.call(context.response.message, _this.middleware.listener, function(listenerExecuted) {
              anyListenersExecuted = anyListenersExecuted || listenerExecuted;
              return Middleware.ticker(function() {
                return cb(context.response.message.done);
              });
            });
          } catch (error1) {
            err = error1;
            _this.emit('error', err, new _this.Response(_this, context.response.message, []));
            return cb(false);
          }
        };
      })(this), (function(_this) {
        return function(_) {
          if (!(context.response.message instanceof CatchAllMessage) && !anyListenersExecuted) {
            _this.logger.debug('No listeners executed; falling back to catch-all');
            return _this.receive(new CatchAllMessage(context.response.message), done);
          } else {
            if (done != null) {
              return process.nextTick(done);
            }
          }
        };
      })(this));
      return void 0;
    };

    Robot.prototype.loadFile = function(path, file) {
      var cacheobj, error, ext, full, script;
      ext = Path.extname(file);
      full = Path.join(path, Path.basename(file, ext));
      if (require.cache[require.resolve(full)]) {
        try {
          cacheobj = require.resolve(full);
          this.logger.debug("require cache for " + cacheobj + " invalidated.");
          delete require.cache[cacheobj];
        } catch (error1) {
          error = error1;
          this.logger.error("Unable to invalidate " + cacheobj + ": " + error.stack);
        }
      }
      if (require.extensions[ext]) {
        try {
          script = require(full);
          if (typeof script === 'function') {
            script(this);
            return this.parseHelp(Path.join(path, file));
          } else {
            return this.logger.warning("Expected " + full + " to assign a function to module.exports, got " + (typeof script));
          }
        } catch (error1) {
          error = error1;
          this.logger.error("Unable to load " + full + ": " + error.stack);
          return process.exit(1);
        }
      }
    };

    Robot.prototype.load = function(path) {
      var file, i, len, ref2, results;
      this.logger.debug("Loading scripts from " + path);
      if (Fs.existsSync(path)) {
        ref2 = Fs.readdirSync(path).sort();
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          file = ref2[i];
          results.push(this.loadFile(path, file));
        }
        return results;
      }
    };

    Robot.prototype.loadHubotScripts = function(path, scripts) {
      var i, len, results, script;
      this.logger.debug("Loading hubot-scripts from " + path);
      results = [];
      for (i = 0, len = scripts.length; i < len; i++) {
        script = scripts[i];
        results.push(this.loadFile(path, script));
      }
      return results;
    };

    Robot.prototype.loadExternalScripts = function(packages) {
      var err, i, len, pkg, results, results1, scripts;
      this.logger.debug("Loading external-scripts from npm packages");
      try {
        if (packages instanceof Array) {
          results = [];
          for (i = 0, len = packages.length; i < len; i++) {
            pkg = packages[i];
            results.push(require(pkg)(this));
          }
          return results;
        } else {
          results1 = [];
          for (pkg in packages) {
            scripts = packages[pkg];
            results1.push(require(pkg)(this, scripts));
          }
          return results1;
        }
      } catch (error1) {
        err = error1;
        this.logger.error("Error loading scripts from npm package - " + err.stack);
        return process.exit(1);
      }
    };

    Robot.prototype.setupExpress = function() {
      var address, app, basicAuth, bodyParser, cookieParser, express, fs, http, https, logger, multipart, options, pass, port, stat, user;
      user          = process.env.EXPRESS_USER;
      pass          = process.env.EXPRESS_PASSWORD;
      stat          = process.env.EXPRESS_STATIC;
      port          = process.env.EXPRESS_PORT || process.env.PORT || 8080;
      address       = process.env.EXPRESS_BIND_ADDRESS || process.env.BIND_ADDRESS || '0.0.0.0';
      express       = require('express');
      multipart     = require('connect-multiparty');
      bodyParser    = require('body-parser');
      basicAuth     = require('basic-auth-connect');
      cookieParser  = require('cookie-parser');
      logger        = require('morgan');
      app           = express();


      app.use(function(req, res, next) {
         global.req = req;
         global.res = res;
         return next();
      });

      app.use(function(req, res, next) {
        res.setHeader("X-Powered-By", "Mubotv0.1.0 / " + this.name);
        return next();
      });

      if(process.env.HUBOT_LOG_LEVEL) app.use(logger("dev"));
      if (user && pass)               app.use("/admin", basicAuth(user, pass));
      if (stat)                       app.use(express.static(stat));
      app.use(bodyParser.json         ({ extended: true }));
      app.use(bodyParser.urlencoded   ({ extended: false }));
      app.use(express.query());
      app.use(cookieParser());
//      app.use(clientCertificateAuth(checkAuth));



      try {
        https   = require('https');
        fs      = require('fs');
        http    = require('http');
        options = {
          key: fs.readFileSync (Path.join(__dirname, '../../hubot-server/credentials/privkey.pem')),
          cert: fs.readFileSync(Path.join(__dirname, '../../hubot-server/credentials/fullchain.pem')),
          ca: fs.readFileSync  (Path.join(__dirname, '../../hubot-server/credentials/chain.pem')),
          requestCert: true,
          rejectUnauthorized: false
        };
        this.server = https.createServer(options, app).listen(4343,function() {
          return console.log('listening on port 4343.');
        }).on('error', (e)=>{
          if(e.code == "EADDRINUSE") return console.log("cant listen on port 4343, address is use.")
        })

        http.createServer(function(req, res) {
          res.writeHead(301, { 'Location': 'https://' + req.headers['host'] + req.url });
          return res.end();
        }).listen(8080, function() {
          return console.log('listening on port 8080.');
        }).on('error', (e)=>{
          if(e.code == "EADDRINUSE") return console.log("cant listen on port 8000, address is use.")
        })
        return this.router = app;
      } catch (err) {
        this.logger.info("Error trying to start HTTP server: " + err + "\n" + err.stack);
        return process.exit(1);
      }
    };

    Robot.prototype.setupNullRouter = function() {
      var msg;
      msg = "A script has tried registering a HTTP route while the HTTP server is disabled with --disabled-httpd.";
      return this.router = {
        get: (function(_this) {
          return function() {
            return _this.logger.warning(msg);
          };
        })(this),
        post: (function(_this) {
          return function() {
            return _this.logger.warning(msg);
          };
        })(this),
        put: (function(_this) {
          return function() {
            return _this.logger.warning(msg);
          };
        })(this),
        "delete": (function(_this) {
          return function() {
            return _this.logger.warning(msg);
          };
        })(this)
      };
    };

    Robot.prototype.loadAdapter = function(adapter) {
      var err, path;
      this.logger.debug("Loading adapter " + adapter);
      try {
        path = indexOf.call(HUBOT_DEFAULT_ADAPTERS, adapter) >= 0 ? this.adapterPath + "/" + adapter : "hubot-" + adapter;
        return this.adapter = require(path).use(this);
      } catch (error1) {
        err = error1;
        this.logger.error("Cannot load adapter " + adapter + " - " + err);
        return process.exit(1);
      }
    };

    Robot.prototype.helpCommands = function() {
      return this.commands.sort();
    };

    Robot.prototype.parseHelp = function(path) {
      var body, cleanedLine, currentSection, i, j, len, len1, line, nextSection, ref2, ref3, results, scriptDocumentation, scriptName;
      this.logger.debug("Parsing help for " + path);
      scriptName = Path.basename(path).replace(/\.(coffee|js)$/, '');
      scriptDocumentation = {};
      body = Fs.readFileSync(path, 'utf-8');
      currentSection = null;
      ref2 = body.split("\n");
      for (i = 0, len = ref2.length; i < len; i++) {
        line = ref2[i];
        if (!(line[0] === '#' || line.substr(0, 2) === '//')) {
          break;
        }
        cleanedLine = line.replace(/^(#|\/\/)\s?/, "").trim();
        if (cleanedLine.length === 0) {
          continue;
        }
        if (cleanedLine.toLowerCase() === 'none') {
          continue;
        }
        nextSection = cleanedLine.toLowerCase().replace(':', '');
        if (indexOf.call(HUBOT_DOCUMENTATION_SECTIONS, nextSection) >= 0) {
          currentSection = nextSection;
          scriptDocumentation[currentSection] = [];
        } else {
          if (currentSection) {
            scriptDocumentation[currentSection].push(cleanedLine.trim());
            if (currentSection === 'commands') {
              this.commands.push(cleanedLine.trim());
            }
          }
        }
      }
      if (currentSection === null) {
        this.logger.info(path + " is using deprecated documentation syntax");
        scriptDocumentation.commands = [];
        ref3 = body.split("\n");
        results = [];
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          line = ref3[j];
          if (!(line[0] === '#' || line.substr(0, 2) === '//')) {
            break;
          }
          if (!line.match('-')) {
            continue;
          }
          cleanedLine = line.slice(2, +line.length + 1 || 9e9).replace(/^hubot/i, this.name).trim();
          scriptDocumentation.commands.push(cleanedLine);
          results.push(this.commands.push(cleanedLine));
        }
        return results;
      }
    };

    Robot.prototype.send = function() {
      var envelope, ref2, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return (ref2 = this.adapter).send.apply(ref2, [envelope].concat(slice.call(strings)));
    };

    Robot.prototype.reply = function() {
      var envelope, ref2, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return (ref2 = this.adapter).reply.apply(ref2, [envelope].concat(slice.call(strings)));
    };

    Robot.prototype.messageRoom = function() {
      var envelope, ref2, room, strings;
      room = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      envelope = {
        room: room
      };
      return (ref2 = this.adapter).send.apply(ref2, [envelope].concat(slice.call(strings)));
    };

    Robot.prototype.on = function() {
      var args, event, ref2;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return (ref2 = this.events).on.apply(ref2, [event].concat(slice.call(args)));
    };

    Robot.prototype.emit = function() {
      var args, event, ref2;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return (ref2 = this.events).emit.apply(ref2, [event].concat(slice.call(args)));
    };

    Robot.prototype.run = function() {
      this.emit("running");
      return this.adapter.run();
    };

    Robot.prototype.shutdown = function() {
      if (this.pingIntervalId != null) {
        clearInterval(this.pingIntervalId);
      }
      process.removeListener('uncaughtException', this.onUncaughtException);
      this.adapter.close();
      return this.brain.close();
    };

    Robot.prototype.parseVersion = function() {
      var pkg;
      pkg = require(Path.join(__dirname, '..', 'package.json'));
      return this.version = pkg.version;
    };

    Robot.prototype.http = function(url, options) {
      return HttpClient.create(url, this.extend({}, this.globalHttpOptions, options)).header('User-Agent', "Hubot/" + this.version);
    };

    Robot.prototype.extend = function() {
      var i, key, len, obj, source, sources, value;
      obj = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        for (key in source) {
          if (!hasProp.call(source, key)) continue;
          value = source[key];
          obj[key] = value;
        }
      }
      return obj;
    };

    return Robot;

  })();

  module.exports = Robot;

}).call(this);
